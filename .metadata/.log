!SESSION 2015-05-03 20:20:51.101 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_45
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=fr_FR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.m2e.logback.configuration 2 0 2015-05-03 20:21:40.763
!MESSAGE Exception while setting up logging:org.eclipse.osgi.internal.framework.EquinoxConfiguration$1 cannot be cast to java.lang.String
!STACK 0
java.lang.ClassCastException: org.eclipse.osgi.internal.framework.EquinoxConfiguration$1 cannot be cast to java.lang.String
	at org.eclipse.m2e.logback.configuration.LogHelper.logJavaProperties(LogHelper.java:26)
	at org.eclipse.m2e.logback.configuration.LogPlugin.loadConfiguration(LogPlugin.java:189)
	at org.eclipse.m2e.logback.configuration.LogPlugin.configureLogback(LogPlugin.java:144)
	at org.eclipse.m2e.logback.configuration.LogPlugin.access$2(LogPlugin.java:107)
	at org.eclipse.m2e.logback.configuration.LogPlugin$1.run(LogPlugin.java:62)
	at java.util.TimerThread.mainLoop(Unknown Source)
	at java.util.TimerThread.run(Unknown Source)

!ENTRY org.eclipse.e4.ui.workbench 4 0 2015-05-03 20:22:02.102
!MESSAGE Error setting focus to : org.eclipse.e4.ui.model.application.ui.basic.impl.PartImpl analyse
!STACK 0
org.eclipse.swt.SWTException: Widget is disposed
	at org.eclipse.swt.SWT.error(SWT.java:4441)
	at org.eclipse.swt.SWT.error(SWT.java:4356)
	at org.eclipse.swt.SWT.error(SWT.java:4327)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:476)
	at org.eclipse.swt.widgets.Widget.checkWidget(Widget.java:348)
	at org.eclipse.swt.widgets.Control.setFocus(Control.java:3320)
	at org.eclipse.swt.widgets.Composite.setFocus(Composite.java:1039)
	at org.eclipse.swt.widgets.Composite.setFocus(Composite.java:1039)
	at org.eclipse.ui.texteditor.StatusTextEditor.setFocus(StatusTextEditor.java:120)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.delegateSetFocus(CompatibilityPart.java:191)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:247)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:253)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:225)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:107)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.focusGui(PartRenderingEngine.java:795)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer$2.setFocus(ContributedPartRenderer.java:100)
	at org.eclipse.swt.custom.CTabItem.setFocus(CTabItem.java:332)
	at org.eclipse.swt.custom.CTabFolder.setFocus(CTabFolder.java:2555)
	at org.eclipse.swt.widgets.Control.fixFocus(Control.java:1052)
	at org.eclipse.swt.widgets.Control.setVisible(Control.java:3818)
	at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3098)
	at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3055)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.showTab(StackRenderer.java:1260)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer$1.handleEvent(LazyStackRenderer.java:68)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler$1.run(UIEventHandler.java:40)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:187)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:156)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4734)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:218)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:36)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:135)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:78)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:39)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:81)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:59)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:374)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:171)
	at org.eclipse.e4.ui.internal.workbench.ModelServiceImpl.showElementInWindow(ModelServiceImpl.java:488)
	at org.eclipse.e4.ui.internal.workbench.ModelServiceImpl.bringToTop(ModelServiceImpl.java:454)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.delegateBringToTop(PartServiceImpl.java:694)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.showPart(PartServiceImpl.java:1131)
	at org.eclipse.ui.internal.WorkbenchPage.busyOpenEditor(WorkbenchPage.java:3210)
	at org.eclipse.ui.internal.WorkbenchPage.access$23(WorkbenchPage.java:3125)
	at org.eclipse.ui.internal.WorkbenchPage$9.run(WorkbenchPage.java:3107)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:3102)
	at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:3066)
	at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:3047)
	at org.eclipse.ui.ide.IDE.openEditorOnFileStore(IDE.java:1139)
	at org.eclipse.ui.internal.ide.EditorAreaDropAdapter.asyncDrop(EditorAreaDropAdapter.java:136)
	at org.eclipse.ui.internal.ide.EditorAreaDropAdapter.access$0(EditorAreaDropAdapter.java:87)
	at org.eclipse.ui.internal.ide.EditorAreaDropAdapter$1.run(EditorAreaDropAdapter.java:81)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4147)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3764)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.egit.ui 2 0 2015-05-03 20:22:19.561
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-05-03 20:22:19.594
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Zack'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.core.resources 2 2 2015-05-03 20:23:07.440
!MESSAGE Save operation warnings.
!SUBENTRY 1 org.eclipse.core.resources 2 234 2015-05-03 20:23:07.440
!MESSAGE The project description file (.project) for 'proj' was missing.  This file contains important information about the project.  A new project description file has been created, but some information about the project may have been lost.

!ENTRY org.eclipse.e4.ui.workbench 4 0 2015-05-03 20:24:29.596
!MESSAGE Error setting focus to : org.eclipse.e4.ui.model.application.ui.basic.impl.PartImpl rechercheFormes
!STACK 0
org.eclipse.swt.SWTException: Widget is disposed
	at org.eclipse.swt.SWT.error(SWT.java:4441)
	at org.eclipse.swt.SWT.error(SWT.java:4356)
	at org.eclipse.swt.SWT.error(SWT.java:4327)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:476)
	at org.eclipse.swt.widgets.Widget.checkWidget(Widget.java:348)
	at org.eclipse.swt.widgets.Control.setFocus(Control.java:3320)
	at org.eclipse.swt.widgets.Composite.setFocus(Composite.java:1039)
	at org.eclipse.swt.widgets.Composite.setFocus(Composite.java:1039)
	at org.eclipse.ui.texteditor.StatusTextEditor.setFocus(StatusTextEditor.java:120)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.delegateSetFocus(CompatibilityPart.java:191)
	at sun.reflect.GeneratedMethodAccessor34.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:247)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:253)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:225)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:107)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.focusGui(PartRenderingEngine.java:795)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer$2.setFocus(ContributedPartRenderer.java:100)
	at org.eclipse.swt.custom.CTabItem.setFocus(CTabItem.java:332)
	at org.eclipse.swt.custom.CTabFolder.setFocus(CTabFolder.java:2555)
	at org.eclipse.swt.widgets.Control.fixFocus(Control.java:1052)
	at org.eclipse.swt.widgets.Control.setVisible(Control.java:3818)
	at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3098)
	at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3106)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1794)
	at org.eclipse.swt.custom.CTabFolder$1.handleEvent(CTabFolder.java:283)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4353)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4172)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3761)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
!SESSION 2015-05-04 12:47:52.115 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_45
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=fr_FR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.m2e.logback.configuration 2 0 2015-05-04 12:48:08.266
!MESSAGE Exception while setting up logging:org.eclipse.osgi.internal.framework.EquinoxConfiguration$1 cannot be cast to java.lang.String
!STACK 0
java.lang.ClassCastException: org.eclipse.osgi.internal.framework.EquinoxConfiguration$1 cannot be cast to java.lang.String
	at org.eclipse.m2e.logback.configuration.LogHelper.logJavaProperties(LogHelper.java:26)
	at org.eclipse.m2e.logback.configuration.LogPlugin.loadConfiguration(LogPlugin.java:189)
	at org.eclipse.m2e.logback.configuration.LogPlugin.configureLogback(LogPlugin.java:144)
	at org.eclipse.m2e.logback.configuration.LogPlugin.access$2(LogPlugin.java:107)
	at org.eclipse.m2e.logback.configuration.LogPlugin$1.run(LogPlugin.java:62)
	at java.util.TimerThread.mainLoop(Unknown Source)
	at java.util.TimerThread.run(Unknown Source)

!ENTRY org.eclipse.egit.core 4 0 2015-05-04 12:48:16.011
!MESSAGE Remove repository mapping of Git mapped resource for which project or mapped git repository has disappeared: 'RepositoryMapping[<empty> -> '../../.git', absolute path: 'C:/cygwin64/home/Zack/.git' ]'
!STACK 0
java.io.FileNotFoundException: 
	at org.eclipse.egit.core.project.GitProjectData.logAndUnmapGoneMappedResource(GitProjectData.java:531)
	at org.eclipse.egit.core.project.GitProjectData.map(GitProjectData.java:497)
	at org.eclipse.egit.core.project.GitProjectData.remapAll(GitProjectData.java:471)
	at org.eclipse.egit.core.project.GitProjectData.load(GitProjectData.java:464)
	at org.eclipse.egit.core.project.GitProjectData.get(GitProjectData.java:204)
	at org.eclipse.egit.core.GitProvider.getData(GitProvider.java:86)
	at org.eclipse.egit.core.project.RepositoryMapping.getMapping(RepositoryMapping.java:268)
	at org.eclipse.egit.ui.Activator$ResourceRefreshJob.triggerRefresh(Activator.java:404)
	at org.eclipse.egit.ui.Activator$2.windowActivated(Activator.java:267)
	at org.eclipse.ui.internal.Workbench$11.run(Workbench.java:1045)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.Workbench.fireWindowActivated(Workbench.java:1042)
	at org.eclipse.ui.internal.WorkbenchWindow$14.shellActivated(WorkbenchWindow.java:2285)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:88)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4353)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1085)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1070)
	at org.eclipse.swt.widgets.Decorations.WM_ACTIVATE(Decorations.java:1666)
	at org.eclipse.swt.widgets.Shell.WM_ACTIVATE(Shell.java:2151)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4607)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:339)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1626)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2075)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5023)
	at org.eclipse.swt.internal.win32.OS.BringWindowToTop(Native Method)
	at org.eclipse.swt.widgets.Decorations.bringToTop(Decorations.java:230)
	at org.eclipse.swt.widgets.Shell.open(Shell.java:1217)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.postProcess(WBWRenderer.java:745)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:678)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$2(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$7.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1078)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.egit.core 4 0 2015-05-04 12:48:16.049
!MESSAGE Remove repository mapping of Git mapped resource for which project or mapped git repository has disappeared: 'RepositoryMapping[<empty> -> '../../.git', absolute path: 'C:/cygwin64/home/Zack/.git' ]'
!STACK 0
java.io.FileNotFoundException: 
	at org.eclipse.egit.core.project.GitProjectData.logAndUnmapGoneMappedResource(GitProjectData.java:531)
	at org.eclipse.egit.core.project.GitProjectData.map(GitProjectData.java:497)
	at org.eclipse.egit.core.project.GitProjectData.remapAll(GitProjectData.java:471)
	at org.eclipse.egit.core.project.GitProjectData.load(GitProjectData.java:464)
	at org.eclipse.egit.core.project.GitProjectData.get(GitProjectData.java:204)
	at org.eclipse.egit.core.GitProvider.getData(GitProvider.java:86)
	at org.eclipse.egit.core.project.RepositoryMapping.getMapping(RepositoryMapping.java:268)
	at org.eclipse.egit.ui.Activator$ResourceRefreshJob.triggerRefresh(Activator.java:404)
	at org.eclipse.egit.ui.Activator$2.windowActivated(Activator.java:267)
	at org.eclipse.ui.internal.Workbench$11.run(Workbench.java:1045)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.Workbench.fireWindowActivated(Workbench.java:1042)
	at org.eclipse.ui.internal.WorkbenchWindow$14.shellActivated(WorkbenchWindow.java:2285)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:88)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4353)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1085)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1070)
	at org.eclipse.swt.widgets.Decorations.WM_ACTIVATE(Decorations.java:1666)
	at org.eclipse.swt.widgets.Shell.WM_ACTIVATE(Shell.java:2151)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4607)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:339)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1626)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2075)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5023)
	at org.eclipse.swt.internal.win32.OS.BringWindowToTop(Native Method)
	at org.eclipse.swt.widgets.Decorations.bringToTop(Decorations.java:230)
	at org.eclipse.swt.widgets.Shell.open(Shell.java:1217)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.postProcess(WBWRenderer.java:745)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:678)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$2(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$7.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1078)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.egit.ui 2 0 2015-05-04 12:48:17.013
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-05-04 12:48:17.052
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Zack'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2015-05-04 12:50:22.849
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package rechercheFormes;


import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;


public class RechercheFormes {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String uneLigne = null;
		//la ligne qu'on lit actuellement
		boolean fini = false;
		//pour arreter l'analyse
		int[] tablargeurhauteur = new int[2];
		//tableau qui recupere la largeur et la hauteur
		
		String schiffre ="";
		//variable servant a faire la concatenation des chiffres, qu'on transformera apres en entier 
	
		uneLigne = br.readLine();
		//recuperation de la largeur et la hauteur 
		
		
		int unchiffre = 0;
		// ici i =1 car on commence par le deuxieme caractere pour eviter le 1er caractere qui sera un '|'
		for (int i=1; i<= uneLigne.length()-1;i++){
			if(uneLigne.charAt(i)==' '){
			tablargeurhauteur[unchiffre]= Integer.parseInt(schiffre); 
				unchiffre++;
				schiffre = "";
			}
			else{
				
				schiffre = schiffre + uneLigne.charAt(i);
				
			}
			
			
		}
		
		int largeur = tablargeurhauteur[0]; //tablargeurhauteur[0] sera la largeur,
		int hauteur = tablargeurhauteur[1]; //tablargeurhauteur[1] sera la hauteur
		System.out.println("largeur de l'image = " + largeur);
		System.out.println("hauteur de l'image = " + hauteur);
		
		uneLigne = br.readLine();
		
		// recuperation de la valeur maximale pour chaque composante RGB (inutile)
		
		uneLigne = br.readLine();
		
		
		//ajout de toutes les valeurs dans une matrice 
		
		String [][] point = new String[hauteur][largeur];
		String uneCouleur ="";
		int ligne = 0;
		int colonne = 0;
		while (! fini){ 
			
			for (int i=1; i<= uneLigne.length()-1;i++){
				if(uneLigne.charAt(i)=='|'){
					point[colonne][ligne]= uneCouleur;
					colonne ++;
					uneCouleur ="";
					
				}
				else{
					uneCouleur = uneCouleur +uneLigne.charAt(i);
				}
				
	
			}
				ligne++;
				colonne = 0;
			
			
			uneLigne = br.readLine();


			if (uneLigne == null) {
			fini = true;
			}
			else{
			fini = false;
			}
		}
		br.close();	
		
		//recherche des points a gauche
		
		
		ArrayList<Points>tabgauche = new ArrayList<Points>();

		int jg = 0;
		boolean trouveg;
		
		for (int i=0; i< point.length;i++){
			trouveg = false;
			while (! trouveg){
				
				jg++;
				if(jg==point.length){
					trouveg = true;
				}
				else if (! point[jg][i].equals("255 255 255")){
					tabgauche.add(new Points(jg,i));
					trouveg = true;
					
				}
				else{
					trouveg = false;
				}
				
				
			}
			
			jg = 0;
		}
		
		
		//recherche des points a droite
		
		
		ArrayList<Points>tabdroite = new ArrayList<Points>();

		int jd = point[0].length;
		boolean trouved;
		
		for (int i=0; i< point.length;i++){
			trouved = false;
			while (! trouved){
				
				jd--;
				
				if(jd==0){
					trouved = true;
				}
				else if (! point[jd][i].equals("255 255 255")){
					
					tabdroite.add(new Points(jd,i));
					trouved = true;
					
				}
				else{
					trouved = false;
				}
				
				
			}
			
			jd = point[0].length;
			
		}


		
		//comparaison
		DictionnaireCouleur dico = new DictionnaireCouleur();

		
		
		boolean droiteverticalegauche = false;
		//regarde si la droite de gauche est vertical
		for (int i=0; i<tabgauche.size()-1;i++){
			if (tabgauche.get(i).x==tabgauche.get(i+1).x){
				droiteverticalegauche = true;
			}
			else{
				droiteverticalegauche = false;
				break;
			}
			

		}
		
		
		boolean droiteverticaledroite = false;
		//regarde si la droite de droite est vertical
		for (int i=0; i<tabdroite.size()-1;i++){
			if (tabdroite.get(i).x==tabdroite.get(i+1).x){
				droiteverticaledroite = true;
			}
			else{
				droiteverticaledroite = false;
				break;
			}
			

		}
		
		
		
		boolean memecol = false ;
		//regarde si la droite de gauche est la mÃªme que celle de droite
		for (int i=0; i<tabgauche.size();i++){
			if (tabgauche.get(i).x==tabdroite.get(i).x){
				memecol = true;
			}
			else{
				memecol = false;
			}
			
		}
		
		//regarde si les points constitus un point
		if(tabgauche.get(0).x==tabgauche.get(0).y && tabdroite.get(0).x==tabdroite.get(0).y && tabgauche.size()==1){
			System.out.println("La forme est le point(x="+tabgauche.get(0).x+",y="+tabgauche.get(0).y+") de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
		
		}
		
		else if(droiteverticalegauche && droiteverticaledroite){
			//regarde si les points constitus un segment vertical
			if(memecol){
				System.out.println("La forme est un segment vertical du point(x="+tabgauche.get(0).x+",y="+tabgauche.get(0).y+") au point(x="+tabgauche.get(tabgauche.size()-1).x+",y="+tabgauche.get(tabgauche.size()-1).y+") et de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
			}
			//regarde si les points constitus un rectangle
			else{
				
				System.out.println("La forme est un rectangle qui commence au point(x="+int(tabgauche.get(0).x+1+",y="+tabgauche.get(0).y+1+") de largeur "+(tabdroite.get(0).x-tabgauche.get(0).x)+" pixels, de hauteur "+(tabgauche.get(tabgauche.size()-1).y-tabgauche.get(0).y)+" pixels et de couleur "+ dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
			}
		}
		else {
			boolean estUnCercle=true;
			//regarde si les points constitus un cercle
			for (int j=0;j<(tabgauche.size()/2);j++){
				if(tabgauche.get(j).x != tabgauche.get(tabgauche.size()-(j+1)).x && tabdroite.get(j).x != tabdroite.get(tabdroite.size()-(j+1)).x && !droiteverticalegauche &&  !droiteverticaledroite){
					estUnCercle=false;
				}
				
			}
			if(estUnCercle){
				System.out.print("La forme est un cercle de centre x="+(tabdroite.get((tabdroite.size()-1)/2).x-((tabdroite.get((tabdroite.size()-1)/2).x-tabgauche.get((tabgauche.size()-1)/2).x))/2));
				System.out.print(" y="+(tabgauche.get(tabgauche.size()-1).y-(tabgauche.get(tabgauche.size()-1).y-tabgauche.get(0).y)/2));
				System.out.print(" et de rayon "+(((tabdroite.get((tabdroite.size()-1)/2).x-tabgauche.get((tabgauche.size()-1)/2).x))/2)+" pixels");
				System.out.print(" de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
			}
			else{
				int xMinG=0;
				int xMaxD=0;
				boolean estUnTriangle=false;
				boolean estUnSegment=false;
				//repere le plus grand x du tableau gauche
				for (int k=1;k<(tabgauche.size());k++){
					if (tabgauche.get(xMinG).x > tabgauche.get(k).x){
						xMinG=k;
					}
				}
				 
				//si le plus petit x du tableau gauche est situe au y le plus petit
				if(xMinG==0){
					//on repere le plus petit x du tableau droite
					for (int k=1;k<(tabdroite.size());k++){
						if (tabdroite.get(xMaxD).x < tabdroite.get(k).x){
							xMaxD=k;
						}
					}
					//si le plus grand x du tableau droite est situe au y le plus petit
					if(xMaxD==0){
						estUnTriangle=true;
					}
					//si le plus grand x du tableau droite est situe au y le plus grand
					else if(xMaxD==tabdroite.size()-1){
						//on creer les variables qui nous servent a verifier si un point est dans la droite
						float y2=tabdroite.get(tabdroite.size()-1).y;
						float y1=(tabdroite.get(0)).y;
						float x2=tabdroite.get(tabdroite.size()-1).x;
						float x1=(tabdroite.get(0)).x;
						float X=tabdroite.get((tabdroite.size()-1)/3).x;
						float Y=tabdroite.get((tabdroite.size()-1)/3).y;
						float C=((y2-y1)/(x2-x1));
						float b=y1-(C*x1);
						float p=(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
						//on regarde pour plusieurs points si il y en a un qui appartient a l'equation de la droite
						for (int i=(tabgauche.size()-1)/4;i<tabgauche.size();i++){
							X=tabgauche.get(i).x;
							Y=tabgauche.get(i).y;
							p=(int)(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
							 if (p==0){
							    	estUnSegment=true;
							    }
							    else{
							    	estUnTriangle=true;
							    }
						}
						
					}
					else{
						estUnTriangle=true;
					}
				}
				//si le plus petit x du tableau gauche est situe au y le plus grand
				else if(xMinG==tabgauche.size()-1){
					//repere le plus grand x du tableau droite
					
					for (int k=1;k<(tabdroite.size());k++){
						if (tabdroite.get(xMaxD).x < tabdroite.get(k).x){
							xMaxD=k;
						}
					}
					//si le plus grand x du tableau droite est situe au y le plus petit
					if(xMaxD==0){
						//on creer les variables qui nous servent a verifier si un point est dans la droite
						float y2=tabdroite.get(tabdroite.size()-1).y;
						float y1=(tabdroite.get(0)).y;
						float x2=tabdroite.get(tabdroite.size()-1).x;
						float x1=(tabdroite.get(0)).x;
						float X=tabdroite.get((tabdroite.size()-1)/2).x;
						float Y=tabdroite.get((tabdroite.size()-1)/2).y;
						float C=((y2-y1)/(x2-x1));
						float b=y1-(C*x1);
						float p=(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
						//on regarde pour plusieurs points si il y en a un qui appartient a l'equation de la droite
						for (int i=(tabgauche.size()-1)/4;i<tabgauche.size();i++){
							X=tabgauche.get(i).x;
							Y=tabgauche.get(i).y;
							p=(int)(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
							 if (p==0){
							    	estUnSegment=true;
							    }
							    else{
							    	estUnTriangle=true;
							    }
						}
					}
					//si le plus grand x du tableau droite est situe au y le plus grand
					else if(xMaxD==tabgauche.size()-1){
						estUnTriangle=true;
					}
					else{
						estUnTriangle=true;
					}
				}
				//si le plus petit x du tableau gauche n'est ni situe au y le plus petit ni au y le plus grand c'est un triangle
				else{
					//on creer les variables qui nous servent a verifier si un point est dans la droite
					float y2=tabgauche.get(tabgauche.size()-1).y;
					float y1=(tabgauche.get(0)).y;
					float x2=tabgauche.get(tabgauche.size()-1).x;
					float x1=(tabgauche.get(0)).x;
					float X=tabgauche.get((tabgauche.size()-1)/2).x;
					float Y=tabgauche.get((tabgauche.size()-1)/2).y;
					float C=((y2-y1)/(x2-x1));
					float b=y1-(C*x1);
					float p=(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
					//on regarde pour plusieur point si il y en a un qui appartient a l'equation de la droite
					for (int i=(tabgauche.size()-1)/4;i<tabgauche.size();i++){
						X=tabgauche.get(i).x;
						Y=tabgauche.get(i).y;
						p=(int)(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
						 if (p==0){
						    	estUnSegment=true;
						    }
						    else{
						    	estUnTriangle=true;
						    }
					}
				   
				}
				if(estUnSegment){
					System.out.print("La forme est un segment de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
				}
				else {
					System.out.print("La forme est un triangle de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
					
				}
			}
		}

		



	}

}




----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1768)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3231)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1683)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1090)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1714)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1948)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:207)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-05-04 12:50:22.866
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1768)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3231)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1683)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1090)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1714)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1948)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:207)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-05-04 12:50:22.876
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1768)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3231)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1683)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1090)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1714)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1948)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:207)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-05-04 12:50:24.172
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package rechercheFormes;


import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;


public class RechercheFormes {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String uneLigne = null;
		//la ligne qu'on lit actuellement
		boolean fini = false;
		//pour arreter l'analyse
		int[] tablargeurhauteur = new int[2];
		//tableau qui recupere la largeur et la hauteur
		
		String schiffre ="";
		//variable servant a faire la concatenation des chiffres, qu'on transformera apres en entier 
	
		uneLigne = br.readLine();
		//recuperation de la largeur et la hauteur 
		
		
		int unchiffre = 0;
		// ici i =1 car on commence par le deuxieme caractere pour eviter le 1er caractere qui sera un '|'
		for (int i=1; i<= uneLigne.length()-1;i++){
			if(uneLigne.charAt(i)==' '){
			tablargeurhauteur[unchiffre]= Integer.parseInt(schiffre); 
				unchiffre++;
				schiffre = "";
			}
			else{
				
				schiffre = schiffre + uneLigne.charAt(i);
				
			}
			
			
		}
		
		int largeur = tablargeurhauteur[0]; //tablargeurhauteur[0] sera la largeur,
		int hauteur = tablargeurhauteur[1]; //tablargeurhauteur[1] sera la hauteur
		System.out.println("largeur de l'image = " + largeur);
		System.out.println("hauteur de l'image = " + hauteur);
		
		uneLigne = br.readLine();
		
		// recuperation de la valeur maximale pour chaque composante RGB (inutile)
		
		uneLigne = br.readLine();
		
		
		//ajout de toutes les valeurs dans une matrice 
		
		String [][] point = new String[hauteur][largeur];
		String uneCouleur ="";
		int ligne = 0;
		int colonne = 0;
		while (! fini){ 
			
			for (int i=1; i<= uneLigne.length()-1;i++){
				if(uneLigne.charAt(i)=='|'){
					point[colonne][ligne]= uneCouleur;
					colonne ++;
					uneCouleur ="";
					
				}
				else{
					uneCouleur = uneCouleur +uneLigne.charAt(i);
				}
				
	
			}
				ligne++;
				colonne = 0;
			
			
			uneLigne = br.readLine();


			if (uneLigne == null) {
			fini = true;
			}
			else{
			fini = false;
			}
		}
		br.close();	
		
		//recherche des points a gauche
		
		
		ArrayList<Points>tabgauche = new ArrayList<Points>();

		int jg = 0;
		boolean trouveg;
		
		for (int i=0; i< point.length;i++){
			trouveg = false;
			while (! trouveg){
				
				jg++;
				if(jg==point.length){
					trouveg = true;
				}
				else if (! point[jg][i].equals("255 255 255")){
					tabgauche.add(new Points(jg,i));
					trouveg = true;
					
				}
				else{
					trouveg = false;
				}
				
				
			}
			
			jg = 0;
		}
		
		
		//recherche des points a droite
		
		
		ArrayList<Points>tabdroite = new ArrayList<Points>();

		int jd = point[0].length;
		boolean trouved;
		
		for (int i=0; i< point.length;i++){
			trouved = false;
			while (! trouved){
				
				jd--;
				
				if(jd==0){
					trouved = true;
				}
				else if (! point[jd][i].equals("255 255 255")){
					
					tabdroite.add(new Points(jd,i));
					trouved = true;
					
				}
				else{
					trouved = false;
				}
				
				
			}
			
			jd = point[0].length;
			
		}


		
		//comparaison
		DictionnaireCouleur dico = new DictionnaireCouleur();

		
		
		boolean droiteverticalegauche = false;
		//regarde si la droite de gauche est vertical
		for (int i=0; i<tabgauche.size()-1;i++){
			if (tabgauche.get(i).x==tabgauche.get(i+1).x){
				droiteverticalegauche = true;
			}
			else{
				droiteverticalegauche = false;
				break;
			}
			

		}
		
		
		boolean droiteverticaledroite = false;
		//regarde si la droite de droite est vertical
		for (int i=0; i<tabdroite.size()-1;i++){
			if (tabdroite.get(i).x==tabdroite.get(i+1).x){
				droiteverticaledroite = true;
			}
			else{
				droiteverticaledroite = false;
				break;
			}
			

		}
		
		
		
		boolean memecol = false ;
		//regarde si la droite de gauche est la mÃªme que celle de droite
		for (int i=0; i<tabgauche.size();i++){
			if (tabgauche.get(i).x==tabdroite.get(i).x){
				memecol = true;
			}
			else{
				memecol = false;
			}
			
		}
		
		//regarde si les points constitus un point
		if(tabgauche.get(0).x==tabgauche.get(0).y && tabdroite.get(0).x==tabdroite.get(0).y && tabgauche.size()==1){
			System.out.println("La forme est le point(x="+tabgauche.get(0).x+",y="+tabgauche.get(0).y+") de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
		
		}
		
		else if(droiteverticalegauche && droiteverticaledroite){
			//regarde si les points constitus un segment vertical
			if(memecol){
				System.out.println("La forme est un segment vertical du point(x="+tabgauche.get(0).x+",y="+tabgauche.get(0).y+") au point(x="+tabgauche.get(tabgauche.size()-1).x+",y="+tabgauche.get(tabgauche.size()-1).y+") et de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
			}
			//regarde si les points constitus un rectangle
			else{
				
				System.out.println("La forme est un rectangle qui commence au point(x="+int(tabgauche.get(0).x+1+",y="+tabgauche.get(0).y+1+") de largeur "+(tabdroite.get(0).x-tabgauche.get(0).x)+" pixels, de hauteur "+(tabgauche.get(tabgauche.size()-1).y-tabgauche.get(0).y)+" pixels et de couleur "+ dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
			}
		}
		else {
			boolean estUnCercle=true;
			//regarde si les points constitus un cercle
			for (int j=0;j<(tabgauche.size()/2);j++){
				if(tabgauche.get(j).x != tabgauche.get(tabgauche.size()-(j+1)).x && tabdroite.get(j).x != tabdroite.get(tabdroite.size()-(j+1)).x && !droiteverticalegauche &&  !droiteverticaledroite){
					estUnCercle=false;
				}
				
			}
			if(estUnCercle){
				System.out.print("La forme est un cercle de centre x="+(tabdroite.get((tabdroite.size()-1)/2).x-((tabdroite.get((tabdroite.size()-1)/2).x-tabgauche.get((tabgauche.size()-1)/2).x))/2));
				System.out.print(" y="+(tabgauche.get(tabgauche.size()-1).y-(tabgauche.get(tabgauche.size()-1).y-tabgauche.get(0).y)/2));
				System.out.print(" et de rayon "+(((tabdroite.get((tabdroite.size()-1)/2).x-tabgauche.get((tabgauche.size()-1)/2).x))/2)+" pixels");
				System.out.print(" de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
			}
			else{
				int xMinG=0;
				int xMaxD=0;
				boolean estUnTriangle=false;
				boolean estUnSegment=false;
				//repere le plus grand x du tableau gauche
				for (int k=1;k<(tabgauche.size());k++){
					if (tabgauche.get(xMinG).x > tabgauche.get(k).x){
						xMinG=k;
					}
				}
				 
				//si le plus petit x du tableau gauche est situe au y le plus petit
				if(xMinG==0){
					//on repere le plus petit x du tableau droite
					for (int k=1;k<(tabdroite.size());k++){
						if (tabdroite.get(xMaxD).x < tabdroite.get(k).x){
							xMaxD=k;
						}
					}
					//si le plus grand x du tableau droite est situe au y le plus petit
					if(xMaxD==0){
						estUnTriangle=true;
					}
					//si le plus grand x du tableau droite est situe au y le plus grand
					else if(xMaxD==tabdroite.size()-1){
						//on creer les variables qui nous servent a verifier si un point est dans la droite
						float y2=tabdroite.get(tabdroite.size()-1).y;
						float y1=(tabdroite.get(0)).y;
						float x2=tabdroite.get(tabdroite.size()-1).x;
						float x1=(tabdroite.get(0)).x;
						float X=tabdroite.get((tabdroite.size()-1)/3).x;
						float Y=tabdroite.get((tabdroite.size()-1)/3).y;
						float C=((y2-y1)/(x2-x1));
						float b=y1-(C*x1);
						float p=(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
						//on regarde pour plusieurs points si il y en a un qui appartient a l'equation de la droite
						for (int i=(tabgauche.size()-1)/4;i<tabgauche.size();i++){
							X=tabgauche.get(i).x;
							Y=tabgauche.get(i).y;
							p=(int)(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
							 if (p==0){
							    	estUnSegment=true;
							    }
							    else{
							    	estUnTriangle=true;
							    }
						}
						
					}
					else{
						estUnTriangle=true;
					}
				}
				//si le plus petit x du tableau gauche est situe au y le plus grand
				else if(xMinG==tabgauche.size()-1){
					//repere le plus grand x du tableau droite
					
					for (int k=1;k<(tabdroite.size());k++){
						if (tabdroite.get(xMaxD).x < tabdroite.get(k).x){
							xMaxD=k;
						}
					}
					//si le plus grand x du tableau droite est situe au y le plus petit
					if(xMaxD==0){
						//on creer les variables qui nous servent a verifier si un point est dans la droite
						float y2=tabdroite.get(tabdroite.size()-1).y;
						float y1=(tabdroite.get(0)).y;
						float x2=tabdroite.get(tabdroite.size()-1).x;
						float x1=(tabdroite.get(0)).x;
						float X=tabdroite.get((tabdroite.size()-1)/2).x;
						float Y=tabdroite.get((tabdroite.size()-1)/2).y;
						float C=((y2-y1)/(x2-x1));
						float b=y1-(C*x1);
						float p=(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
						//on regarde pour plusieurs points si il y en a un qui appartient a l'equation de la droite
						for (int i=(tabgauche.size()-1)/4;i<tabgauche.size();i++){
							X=tabgauche.get(i).x;
							Y=tabgauche.get(i).y;
							p=(int)(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
							 if (p==0){
							    	estUnSegment=true;
							    }
							    else{
							    	estUnTriangle=true;
							    }
						}
					}
					//si le plus grand x du tableau droite est situe au y le plus grand
					else if(xMaxD==tabgauche.size()-1){
						estUnTriangle=true;
					}
					else{
						estUnTriangle=true;
					}
				}
				//si le plus petit x du tableau gauche n'est ni situe au y le plus petit ni au y le plus grand c'est un triangle
				else{
					//on creer les variables qui nous servent a verifier si un point est dans la droite
					float y2=tabgauche.get(tabgauche.size()-1).y;
					float y1=(tabgauche.get(0)).y;
					float x2=tabgauche.get(tabgauche.size()-1).x;
					float x1=(tabgauche.get(0)).x;
					float X=tabgauche.get((tabgauche.size()-1)/2).x;
					float Y=tabgauche.get((tabgauche.size()-1)/2).y;
					float C=((y2-y1)/(x2-x1));
					float b=y1-(C*x1);
					float p=(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
					//on regarde pour plusieur point si il y en a un qui appartient a l'equation de la droite
					for (int i=(tabgauche.size()-1)/4;i<tabgauche.size();i++){
						X=tabgauche.get(i).x;
						Y=tabgauche.get(i).y;
						p=(int)(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
						 if (p==0){
						    	estUnSegment=true;
						    }
						    else{
						    	estUnTriangle=true;
						    }
					}
				   
				}
				if(estUnSegment){
					System.out.print("La forme est un segment de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
				}
				else {
					System.out.print("La forme est un triangle de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
					
				}
			}
		}

		



	}

}




----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1768)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3231)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1683)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1090)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1714)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1948)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 2 2015-05-04 12:50:24.226
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1768)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3231)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1683)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1090)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1714)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1948)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 0 2015-05-04 12:50:24.237
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1768)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3231)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1683)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1090)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1714)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1948)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.core 4 4 2015-05-04 12:50:24.316
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package rechercheFormes;


import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;


public class RechercheFormes {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String uneLigne = null;
		//la ligne qu'on lit actuellement
		boolean fini = false;
		//pour arreter l'analyse
		int[] tablargeurhauteur = new int[2];
		//tableau qui recupere la largeur et la hauteur
		
		String schiffre ="";
		//variable servant a faire la concatenation des chiffres, qu'on transformera apres en entier 
	
		uneLigne = br.readLine();
		//recuperation de la largeur et la hauteur 
		
		
		int unchiffre = 0;
		// ici i =1 car on commence par le deuxieme caractere pour eviter le 1er caractere qui sera un '|'
		for (int i=1; i<= uneLigne.length()-1;i++){
			if(uneLigne.charAt(i)==' '){
			tablargeurhauteur[unchiffre]= Integer.parseInt(schiffre); 
				unchiffre++;
				schiffre = "";
			}
			else{
				
				schiffre = schiffre + uneLigne.charAt(i);
				
			}
			
			
		}
		
		int largeur = tablargeurhauteur[0]; //tablargeurhauteur[0] sera la largeur,
		int hauteur = tablargeurhauteur[1]; //tablargeurhauteur[1] sera la hauteur
		System.out.println("largeur de l'image = " + largeur);
		System.out.println("hauteur de l'image = " + hauteur);
		
		uneLigne = br.readLine();
		
		// recuperation de la valeur maximale pour chaque composante RGB (inutile)
		
		uneLigne = br.readLine();
		
		
		//ajout de toutes les valeurs dans une matrice 
		
		String [][] point = new String[hauteur][largeur];
		String uneCouleur ="";
		int ligne = 0;
		int colonne = 0;
		while (! fini){ 
			
			for (int i=1; i<= uneLigne.length()-1;i++){
				if(uneLigne.charAt(i)=='|'){
					point[colonne][ligne]= uneCouleur;
					colonne ++;
					uneCouleur ="";
					
				}
				else{
					uneCouleur = uneCouleur +uneLigne.charAt(i);
				}
				
	
			}
				ligne++;
				colonne = 0;
			
			
			uneLigne = br.readLine();


			if (uneLigne == null) {
			fini = true;
			}
			else{
			fini = false;
			}
		}
		br.close();	
		
		//recherche des points a gauche
		
		
		ArrayList<Points>tabgauche = new ArrayList<Points>();

		int jg = 0;
		boolean trouveg;
		
		for (int i=0; i< point.length;i++){
			trouveg = false;
			while (! trouveg){
				
				jg++;
				if(jg==point.length){
					trouveg = true;
				}
				else if (! point[jg][i].equals("255 255 255")){
					tabgauche.add(new Points(jg,i));
					trouveg = true;
					
				}
				else{
					trouveg = false;
				}
				
				
			}
			
			jg = 0;
		}
		
		
		//recherche des points a droite
		
		
		ArrayList<Points>tabdroite = new ArrayList<Points>();

		int jd = point[0].length;
		boolean trouved;
		
		for (int i=0; i< point.length;i++){
			trouved = false;
			while (! trouved){
				
				jd--;
				
				if(jd==0){
					trouved = true;
				}
				else if (! point[jd][i].equals("255 255 255")){
					
					tabdroite.add(new Points(jd,i));
					trouved = true;
					
				}
				else{
					trouved = false;
				}
				
				
			}
			
			jd = point[0].length;
			
		}


		
		//comparaison
		DictionnaireCouleur dico = new DictionnaireCouleur();

		
		
		boolean droiteverticalegauche = false;
		//regarde si la droite de gauche est vertical
		for (int i=0; i<tabgauche.size()-1;i++){
			if (tabgauche.get(i).x==tabgauche.get(i+1).x){
				droiteverticalegauche = true;
			}
			else{
				droiteverticalegauche = false;
				break;
			}
			

		}
		
		
		boolean droiteverticaledroite = false;
		//regarde si la droite de droite est vertical
		for (int i=0; i<tabdroite.size()-1;i++){
			if (tabdroite.get(i).x==tabdroite.get(i+1).x){
				droiteverticaledroite = true;
			}
			else{
				droiteverticaledroite = false;
				break;
			}
			

		}
		
		
		
		boolean memecol = false ;
		//regarde si la droite de gauche est la mÃªme que celle de droite
		for (int i=0; i<tabgauche.size();i++){
			if (tabgauche.get(i).x==tabdroite.get(i).x){
				memecol = true;
			}
			else{
				memecol = false;
			}
			
		}
		
		//regarde si les points constitus un point
		if(tabgauche.get(0).x==tabgauche.get(0).y && tabdroite.get(0).x==tabdroite.get(0).y && tabgauche.size()==1){
			System.out.println("La forme est le point(x="+tabgauche.get(0).x+",y="+tabgauche.get(0).y+") de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
		
		}
		
		else if(droiteverticalegauche && droiteverticaledroite){
			//regarde si les points constitus un segment vertical
			if(memecol){
				System.out.println("La forme est un segment vertical du point(x="+tabgauche.get(0).x+",y="+tabgauche.get(0).y+") au point(x="+tabgauche.get(tabgauche.size()-1).x+",y="+tabgauche.get(tabgauche.size()-1).y+") et de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
			}
			//regarde si les points constitus un rectangle
			else{
				
				System.out.println("La forme est un rectangle qui commence au point(x="+int(tabgauche.get(0).x+1+",y="+tabgauche.get(0).y+1+") de largeur "+(tabdroite.get(0).x-tabgauche.get(0).x)+" pixels, de hauteur "+(tabgauche.get(tabgauche.size()-1).y-tabgauche.get(0).y)+" pixels et de couleur "+ dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
			}
		}
		else {
			boolean estUnCercle=true;
			//regarde si les points constitus un cercle
			for (int j=0;j<(tabgauche.size()/2);j++){
				if(tabgauche.get(j).x != tabgauche.get(tabgauche.size()-(j+1)).x && tabdroite.get(j).x != tabdroite.get(tabdroite.size()-(j+1)).x && !droiteverticalegauche &&  !droiteverticaledroite){
					estUnCercle=false;
				}
				
			}
			if(estUnCercle){
				System.out.print("La forme est un cercle de centre x="+(tabdroite.get((tabdroite.size()-1)/2).x-((tabdroite.get((tabdroite.size()-1)/2).x-tabgauche.get((tabgauche.size()-1)/2).x))/2));
				System.out.print(" y="+(tabgauche.get(tabgauche.size()-1).y-(tabgauche.get(tabgauche.size()-1).y-tabgauche.get(0).y)/2));
				System.out.print(" et de rayon "+(((tabdroite.get((tabdroite.size()-1)/2).x-tabgauche.get((tabgauche.size()-1)/2).x))/2)+" pixels");
				System.out.print(" de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
			}
			else{
				int xMinG=0;
				int xMaxD=0;
				boolean estUnTriangle=false;
				boolean estUnSegment=false;
				//repere le plus grand x du tableau gauche
				for (int k=1;k<(tabgauche.size());k++){
					if (tabgauche.get(xMinG).x > tabgauche.get(k).x){
						xMinG=k;
					}
				}
				 
				//si le plus petit x du tableau gauche est situe au y le plus petit
				if(xMinG==0){
					//on repere le plus petit x du tableau droite
					for (int k=1;k<(tabdroite.size());k++){
						if (tabdroite.get(xMaxD).x < tabdroite.get(k).x){
							xMaxD=k;
						}
					}
					//si le plus grand x du tableau droite est situe au y le plus petit
					if(xMaxD==0){
						estUnTriangle=true;
					}
					//si le plus grand x du tableau droite est situe au y le plus grand
					else if(xMaxD==tabdroite.size()-1){
						//on creer les variables qui nous servent a verifier si un point est dans la droite
						float y2=tabdroite.get(tabdroite.size()-1).y;
						float y1=(tabdroite.get(0)).y;
						float x2=tabdroite.get(tabdroite.size()-1).x;
						float x1=(tabdroite.get(0)).x;
						float X=tabdroite.get((tabdroite.size()-1)/3).x;
						float Y=tabdroite.get((tabdroite.size()-1)/3).y;
						float C=((y2-y1)/(x2-x1));
						float b=y1-(C*x1);
						float p=(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
						//on regarde pour plusieurs points si il y en a un qui appartient a l'equation de la droite
						for (int i=(tabgauche.size()-1)/4;i<tabgauche.size();i++){
							X=tabgauche.get(i).x;
							Y=tabgauche.get(i).y;
							p=(int)(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
							 if (p==0){
							    	estUnSegment=true;
							    }
							    else{
							    	estUnTriangle=true;
							    }
						}
						
					}
					else{
						estUnTriangle=true;
					}
				}
				//si le plus petit x du tableau gauche est situe au y le plus grand
				else if(xMinG==tabgauche.size()-1){
					//repere le plus grand x du tableau droite
					
					for (int k=1;k<(tabdroite.size());k++){
						if (tabdroite.get(xMaxD).x < tabdroite.get(k).x){
							xMaxD=k;
						}
					}
					//si le plus grand x du tableau droite est situe au y le plus petit
					if(xMaxD==0){
						//on creer les variables qui nous servent a verifier si un point est dans la droite
						float y2=tabdroite.get(tabdroite.size()-1).y;
						float y1=(tabdroite.get(0)).y;
						float x2=tabdroite.get(tabdroite.size()-1).x;
						float x1=(tabdroite.get(0)).x;
						float X=tabdroite.get((tabdroite.size()-1)/2).x;
						float Y=tabdroite.get((tabdroite.size()-1)/2).y;
						float C=((y2-y1)/(x2-x1));
						float b=y1-(C*x1);
						float p=(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
						//on regarde pour plusieurs points si il y en a un qui appartient a l'equation de la droite
						for (int i=(tabgauche.size()-1)/4;i<tabgauche.size();i++){
							X=tabgauche.get(i).x;
							Y=tabgauche.get(i).y;
							p=(int)(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
							 if (p==0){
							    	estUnSegment=true;
							    }
							    else{
							    	estUnTriangle=true;
							    }
						}
					}
					//si le plus grand x du tableau droite est situe au y le plus grand
					else if(xMaxD==tabgauche.size()-1){
						estUnTriangle=true;
					}
					else{
						estUnTriangle=true;
					}
				}
				//si le plus petit x du tableau gauche n'est ni situe au y le plus petit ni au y le plus grand c'est un triangle
				else{
					//on creer les variables qui nous servent a verifier si un point est dans la droite
					float y2=tabgauche.get(tabgauche.size()-1).y;
					float y1=(tabgauche.get(0)).y;
					float x2=tabgauche.get(tabgauche.size()-1).x;
					float x1=(tabgauche.get(0)).x;
					float X=tabgauche.get((tabgauche.size()-1)/2).x;
					float Y=tabgauche.get((tabgauche.size()-1)/2).y;
					float C=((y2-y1)/(x2-x1));
					float b=y1-(C*x1);
					float p=(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
					//on regarde pour plusieur point si il y en a un qui appartient a l'equation de la droite
					for (int i=(tabgauche.size()-1)/4;i<tabgauche.size();i++){
						X=tabgauche.get(i).x;
						Y=tabgauche.get(i).y;
						p=(int)(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
						 if (p==0){
						    	estUnSegment=true;
						    }
						    else{
						    	estUnTriangle=true;
						    }
					}
				   
				}
				if(estUnSegment){
					System.out.print("La forme est un segment de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
				}
				else {
					System.out.print("La forme est un triangle de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
					
				}
			}
		}

		



	}

}




----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1768)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3231)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1683)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1090)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1714)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1948)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-05-04 12:50:24.346
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1768)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3231)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1683)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1090)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1714)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1948)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-05-04 12:50:24.378
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1768)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3231)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1683)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1090)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1714)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1948)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-05-04 12:50:28.298
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package rechercheFormes;


import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;


public class RechercheFormes {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String uneLigne = null;
		//la ligne qu'on lit actuellement
		boolean fini = false;
		//pour arreter l'analyse
		int[] tablargeurhauteur = new int[2];
		//tableau qui recupere la largeur et la hauteur
		
		String schiffre ="";
		//variable servant a faire la concatenation des chiffres, qu'on transformera apres en entier 
	
		uneLigne = br.readLine();
		//recuperation de la largeur et la hauteur 
		
		
		int unchiffre = 0;
		// ici i =1 car on commence par le deuxieme caractere pour eviter le 1er caractere qui sera un '|'
		for (int i=1; i<= uneLigne.length()-1;i++){
			if(uneLigne.charAt(i)==' '){
			tablargeurhauteur[unchiffre]= Integer.parseInt(schiffre); 
				unchiffre++;
				schiffre = "";
			}
			else{
				
				schiffre = schiffre + uneLigne.charAt(i);
				
			}
			
			
		}
		
		int largeur = tablargeurhauteur[0]; //tablargeurhauteur[0] sera la largeur,
		int hauteur = tablargeurhauteur[1]; //tablargeurhauteur[1] sera la hauteur
		System.out.println("largeur de l'image = " + largeur);
		System.out.println("hauteur de l'image = " + hauteur);
		
		uneLigne = br.readLine();
		
		// recuperation de la valeur maximale pour chaque composante RGB (inutile)
		
		uneLigne = br.readLine();
		
		
		//ajout de toutes les valeurs dans une matrice 
		
		String [][] point = new String[hauteur][largeur];
		String uneCouleur ="";
		int ligne = 0;
		int colonne = 0;
		while (! fini){ 
			
			for (int i=1; i<= uneLigne.length()-1;i++){
				if(uneLigne.charAt(i)=='|'){
					point[colonne][ligne]= uneCouleur;
					colonne ++;
					uneCouleur ="";
					
				}
				else{
					uneCouleur = uneCouleur +uneLigne.charAt(i);
				}
				
	
			}
				ligne++;
				colonne = 0;
			
			
			uneLigne = br.readLine();


			if (uneLigne == null) {
			fini = true;
			}
			else{
			fini = false;
			}
		}
		br.close();	
		
		//recherche des points a gauche
		
		
		ArrayList<Points>tabgauche = new ArrayList<Points>();

		int jg = 0;
		boolean trouveg;
		
		for (int i=0; i< point.length;i++){
			trouveg = false;
			while (! trouveg){
				
				jg++;
				if(jg==point.length){
					trouveg = true;
				}
				else if (! point[jg][i].equals("255 255 255")){
					tabgauche.add(new Points(jg,i));
					trouveg = true;
					
				}
				else{
					trouveg = false;
				}
				
				
			}
			
			jg = 0;
		}
		
		
		//recherche des points a droite
		
		
		ArrayList<Points>tabdroite = new ArrayList<Points>();

		int jd = point[0].length;
		boolean trouved;
		
		for (int i=0; i< point.length;i++){
			trouved = false;
			while (! trouved){
				
				jd--;
				
				if(jd==0){
					trouved = true;
				}
				else if (! point[jd][i].equals("255 255 255")){
					
					tabdroite.add(new Points(jd,i));
					trouved = true;
					
				}
				else{
					trouved = false;
				}
				
				
			}
			
			jd = point[0].length;
			
		}


		
		//comparaison
		DictionnaireCouleur dico = new DictionnaireCouleur();

		
		
		boolean droiteverticalegauche = false;
		//regarde si la droite de gauche est vertical
		for (int i=0; i<tabgauche.size()-1;i++){
			if (tabgauche.get(i).x==tabgauche.get(i+1).x){
				droiteverticalegauche = true;
			}
			else{
				droiteverticalegauche = false;
				break;
			}
			

		}
		
		
		boolean droiteverticaledroite = false;
		//regarde si la droite de droite est vertical
		for (int i=0; i<tabdroite.size()-1;i++){
			if (tabdroite.get(i).x==tabdroite.get(i+1).x){
				droiteverticaledroite = true;
			}
			else{
				droiteverticaledroite = false;
				break;
			}
			

		}
		
		
		
		boolean memecol = false ;
		//regarde si la droite de gauche est la mÃªme que celle de droite
		for (int i=0; i<tabgauche.size();i++){
			if (tabgauche.get(i).x==tabdroite.get(i).x){
				memecol = true;
			}
			else{
				memecol = false;
			}
			
		}
		
		//regarde si les points constitus un point
		if(tabgauche.get(0).x==tabgauche.get(0).y && tabdroite.get(0).x==tabdroite.get(0).y && tabgauche.size()==1){
			System.out.println("La forme est le point(x="+tabgauche.get(0).x+",y="+tabgauche.get(0).y+") de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
		
		}
		
		else if(droiteverticalegauche && droiteverticaledroite){
			//regarde si les points constitus un segment vertical
			if(memecol){
				System.out.println("La forme est un segment vertical du point(x="+tabgauche.get(0).x+",y="+tabgauche.get(0).y+") au point(x="+tabgauche.get(tabgauche.size()-1).x+",y="+tabgauche.get(tabgauche.size()-1).y+") et de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
			}
			//regarde si les points constitus un rectangle
			else{
				
				System.out.println("La forme est un rectangle qui commence au point(x="+int(tabgauche.get(0).x+1+",y=")+int(tabgauche.get(0).y+1+") de largeur "+(tabdroite.get(0).x-tabgauche.get(0).x)+" pixels, de hauteur "+(tabgauche.get(tabgauche.size()-1).y-tabgauche.get(0).y)+" pixels et de couleur "+ dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
			}
		}
		else {
			boolean estUnCercle=true;
			//regarde si les points constitus un cercle
			for (int j=0;j<(tabgauche.size()/2);j++){
				if(tabgauche.get(j).x != tabgauche.get(tabgauche.size()-(j+1)).x && tabdroite.get(j).x != tabdroite.get(tabdroite.size()-(j+1)).x && !droiteverticalegauche &&  !droiteverticaledroite){
					estUnCercle=false;
				}
				
			}
			if(estUnCercle){
				System.out.print("La forme est un cercle de centre x="+(tabdroite.get((tabdroite.size()-1)/2).x-((tabdroite.get((tabdroite.size()-1)/2).x-tabgauche.get((tabgauche.size()-1)/2).x))/2));
				System.out.print(" y="+(tabgauche.get(tabgauche.size()-1).y-(tabgauche.get(tabgauche.size()-1).y-tabgauche.get(0).y)/2));
				System.out.print(" et de rayon "+(((tabdroite.get((tabdroite.size()-1)/2).x-tabgauche.get((tabgauche.size()-1)/2).x))/2)+" pixels");
				System.out.print(" de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
			}
			else{
				int xMinG=0;
				int xMaxD=0;
				boolean estUnTriangle=false;
				boolean estUnSegment=false;
				//repere le plus grand x du tableau gauche
				for (int k=1;k<(tabgauche.size());k++){
					if (tabgauche.get(xMinG).x > tabgauche.get(k).x){
						xMinG=k;
					}
				}
				 
				//si le plus petit x du tableau gauche est situe au y le plus petit
				if(xMinG==0){
					//on repere le plus petit x du tableau droite
					for (int k=1;k<(tabdroite.size());k++){
						if (tabdroite.get(xMaxD).x < tabdroite.get(k).x){
							xMaxD=k;
						}
					}
					//si le plus grand x du tableau droite est situe au y le plus petit
					if(xMaxD==0){
						estUnTriangle=true;
					}
					//si le plus grand x du tableau droite est situe au y le plus grand
					else if(xMaxD==tabdroite.size()-1){
						//on creer les variables qui nous servent a verifier si un point est dans la droite
						float y2=tabdroite.get(tabdroite.size()-1).y;
						float y1=(tabdroite.get(0)).y;
						float x2=tabdroite.get(tabdroite.size()-1).x;
						float x1=(tabdroite.get(0)).x;
						float X=tabdroite.get((tabdroite.size()-1)/3).x;
						float Y=tabdroite.get((tabdroite.size()-1)/3).y;
						float C=((y2-y1)/(x2-x1));
						float b=y1-(C*x1);
						float p=(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
						//on regarde pour plusieurs points si il y en a un qui appartient a l'equation de la droite
						for (int i=(tabgauche.size()-1)/4;i<tabgauche.size();i++){
							X=tabgauche.get(i).x;
							Y=tabgauche.get(i).y;
							p=(int)(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
							 if (p==0){
							    	estUnSegment=true;
							    }
							    else{
							    	estUnTriangle=true;
							    }
						}
						
					}
					else{
						estUnTriangle=true;
					}
				}
				//si le plus petit x du tableau gauche est situe au y le plus grand
				else if(xMinG==tabgauche.size()-1){
					//repere le plus grand x du tableau droite
					
					for (int k=1;k<(tabdroite.size());k++){
						if (tabdroite.get(xMaxD).x < tabdroite.get(k).x){
							xMaxD=k;
						}
					}
					//si le plus grand x du tableau droite est situe au y le plus petit
					if(xMaxD==0){
						//on creer les variables qui nous servent a verifier si un point est dans la droite
						float y2=tabdroite.get(tabdroite.size()-1).y;
						float y1=(tabdroite.get(0)).y;
						float x2=tabdroite.get(tabdroite.size()-1).x;
						float x1=(tabdroite.get(0)).x;
						float X=tabdroite.get((tabdroite.size()-1)/2).x;
						float Y=tabdroite.get((tabdroite.size()-1)/2).y;
						float C=((y2-y1)/(x2-x1));
						float b=y1-(C*x1);
						float p=(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
						//on regarde pour plusieurs points si il y en a un qui appartient a l'equation de la droite
						for (int i=(tabgauche.size()-1)/4;i<tabgauche.size();i++){
							X=tabgauche.get(i).x;
							Y=tabgauche.get(i).y;
							p=(int)(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
							 if (p==0){
							    	estUnSegment=true;
							    }
							    else{
							    	estUnTriangle=true;
							    }
						}
					}
					//si le plus grand x du tableau droite est situe au y le plus grand
					else if(xMaxD==tabgauche.size()-1){
						estUnTriangle=true;
					}
					else{
						estUnTriangle=true;
					}
				}
				//si le plus petit x du tableau gauche n'est ni situe au y le plus petit ni au y le plus grand c'est un triangle
				else{
					//on creer les variables qui nous servent a verifier si un point est dans la droite
					float y2=tabgauche.get(tabgauche.size()-1).y;
					float y1=(tabgauche.get(0)).y;
					float x2=tabgauche.get(tabgauche.size()-1).x;
					float x1=(tabgauche.get(0)).x;
					float X=tabgauche.get((tabgauche.size()-1)/2).x;
					float Y=tabgauche.get((tabgauche.size()-1)/2).y;
					float C=((y2-y1)/(x2-x1));
					float b=y1-(C*x1);
					float p=(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
					//on regarde pour plusieur point si il y en a un qui appartient a l'equation de la droite
					for (int i=(tabgauche.size()-1)/4;i<tabgauche.size();i++){
						X=tabgauche.get(i).x;
						Y=tabgauche.get(i).y;
						p=(int)(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
						 if (p==0){
						    	estUnSegment=true;
						    }
						    else{
						    	estUnTriangle=true;
						    }
					}
				   
				}
				if(estUnSegment){
					System.out.print("La forme est un segment de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
				}
				else {
					System.out.print("La forme est un triangle de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
					
				}
			}
		}

		



	}

}




----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1768)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3231)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1683)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1090)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1714)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1948)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-05-04 12:50:28.319
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1768)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3231)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1683)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1090)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1714)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1948)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-05-04 12:50:28.359
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1768)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3231)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1683)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1090)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1714)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1948)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-05-04 12:50:28.443
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package rechercheFormes;


import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;


public class RechercheFormes {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String uneLigne = null;
		//la ligne qu'on lit actuellement
		boolean fini = false;
		//pour arreter l'analyse
		int[] tablargeurhauteur = new int[2];
		//tableau qui recupere la largeur et la hauteur
		
		String schiffre ="";
		//variable servant a faire la concatenation des chiffres, qu'on transformera apres en entier 
	
		uneLigne = br.readLine();
		//recuperation de la largeur et la hauteur 
		
		
		int unchiffre = 0;
		// ici i =1 car on commence par le deuxieme caractere pour eviter le 1er caractere qui sera un '|'
		for (int i=1; i<= uneLigne.length()-1;i++){
			if(uneLigne.charAt(i)==' '){
			tablargeurhauteur[unchiffre]= Integer.parseInt(schiffre); 
				unchiffre++;
				schiffre = "";
			}
			else{
				
				schiffre = schiffre + uneLigne.charAt(i);
				
			}
			
			
		}
		
		int largeur = tablargeurhauteur[0]; //tablargeurhauteur[0] sera la largeur,
		int hauteur = tablargeurhauteur[1]; //tablargeurhauteur[1] sera la hauteur
		System.out.println("largeur de l'image = " + largeur);
		System.out.println("hauteur de l'image = " + hauteur);
		
		uneLigne = br.readLine();
		
		// recuperation de la valeur maximale pour chaque composante RGB (inutile)
		
		uneLigne = br.readLine();
		
		
		//ajout de toutes les valeurs dans une matrice 
		
		String [][] point = new String[hauteur][largeur];
		String uneCouleur ="";
		int ligne = 0;
		int colonne = 0;
		while (! fini){ 
			
			for (int i=1; i<= uneLigne.length()-1;i++){
				if(uneLigne.charAt(i)=='|'){
					point[colonne][ligne]= uneCouleur;
					colonne ++;
					uneCouleur ="";
					
				}
				else{
					uneCouleur = uneCouleur +uneLigne.charAt(i);
				}
				
	
			}
				ligne++;
				colonne = 0;
			
			
			uneLigne = br.readLine();


			if (uneLigne == null) {
			fini = true;
			}
			else{
			fini = false;
			}
		}
		br.close();	
		
		//recherche des points a gauche
		
		
		ArrayList<Points>tabgauche = new ArrayList<Points>();

		int jg = 0;
		boolean trouveg;
		
		for (int i=0; i< point.length;i++){
			trouveg = false;
			while (! trouveg){
				
				jg++;
				if(jg==point.length){
					trouveg = true;
				}
				else if (! point[jg][i].equals("255 255 255")){
					tabgauche.add(new Points(jg,i));
					trouveg = true;
					
				}
				else{
					trouveg = false;
				}
				
				
			}
			
			jg = 0;
		}
		
		
		//recherche des points a droite
		
		
		ArrayList<Points>tabdroite = new ArrayList<Points>();

		int jd = point[0].length;
		boolean trouved;
		
		for (int i=0; i< point.length;i++){
			trouved = false;
			while (! trouved){
				
				jd--;
				
				if(jd==0){
					trouved = true;
				}
				else if (! point[jd][i].equals("255 255 255")){
					
					tabdroite.add(new Points(jd,i));
					trouved = true;
					
				}
				else{
					trouved = false;
				}
				
				
			}
			
			jd = point[0].length;
			
		}


		
		//comparaison
		DictionnaireCouleur dico = new DictionnaireCouleur();

		
		
		boolean droiteverticalegauche = false;
		//regarde si la droite de gauche est vertical
		for (int i=0; i<tabgauche.size()-1;i++){
			if (tabgauche.get(i).x==tabgauche.get(i+1).x){
				droiteverticalegauche = true;
			}
			else{
				droiteverticalegauche = false;
				break;
			}
			

		}
		
		
		boolean droiteverticaledroite = false;
		//regarde si la droite de droite est vertical
		for (int i=0; i<tabdroite.size()-1;i++){
			if (tabdroite.get(i).x==tabdroite.get(i+1).x){
				droiteverticaledroite = true;
			}
			else{
				droiteverticaledroite = false;
				break;
			}
			

		}
		
		
		
		boolean memecol = false ;
		//regarde si la droite de gauche est la mÃªme que celle de droite
		for (int i=0; i<tabgauche.size();i++){
			if (tabgauche.get(i).x==tabdroite.get(i).x){
				memecol = true;
			}
			else{
				memecol = false;
			}
			
		}
		
		//regarde si les points constitus un point
		if(tabgauche.get(0).x==tabgauche.get(0).y && tabdroite.get(0).x==tabdroite.get(0).y && tabgauche.size()==1){
			System.out.println("La forme est le point(x="+tabgauche.get(0).x+",y="+tabgauche.get(0).y+") de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
		
		}
		
		else if(droiteverticalegauche && droiteverticaledroite){
			//regarde si les points constitus un segment vertical
			if(memecol){
				System.out.println("La forme est un segment vertical du point(x="+tabgauche.get(0).x+",y="+tabgauche.get(0).y+") au point(x="+tabgauche.get(tabgauche.size()-1).x+",y="+tabgauche.get(tabgauche.size()-1).y+") et de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
			}
			//regarde si les points constitus un rectangle
			else{
				
				System.out.println("La forme est un rectangle qui commence au point(x="+int(tabgauche.get(0).x+1+",y=")+int(tabgauche.get(0).y+1+") de largeur "+(tabdroite.get(0).x-tabgauche.get(0).x)+" pixels, de hauteur "+(tabgauche.get(tabgauche.size()-1).y-tabgauche.get(0).y)+" pixels et de couleur "+ dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
			}
		}
		else {
			boolean estUnCercle=true;
			//regarde si les points constitus un cercle
			for (int j=0;j<(tabgauche.size()/2);j++){
				if(tabgauche.get(j).x != tabgauche.get(tabgauche.size()-(j+1)).x && tabdroite.get(j).x != tabdroite.get(tabdroite.size()-(j+1)).x && !droiteverticalegauche &&  !droiteverticaledroite){
					estUnCercle=false;
				}
				
			}
			if(estUnCercle){
				System.out.print("La forme est un cercle de centre x="+(tabdroite.get((tabdroite.size()-1)/2).x-((tabdroite.get((tabdroite.size()-1)/2).x-tabgauche.get((tabgauche.size()-1)/2).x))/2));
				System.out.print(" y="+(tabgauche.get(tabgauche.size()-1).y-(tabgauche.get(tabgauche.size()-1).y-tabgauche.get(0).y)/2));
				System.out.print(" et de rayon "+(((tabdroite.get((tabdroite.size()-1)/2).x-tabgauche.get((tabgauche.size()-1)/2).x))/2)+" pixels");
				System.out.print(" de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
			}
			else{
				int xMinG=0;
				int xMaxD=0;
				boolean estUnTriangle=false;
				boolean estUnSegment=false;
				//repere le plus grand x du tableau gauche
				for (int k=1;k<(tabgauche.size());k++){
					if (tabgauche.get(xMinG).x > tabgauche.get(k).x){
						xMinG=k;
					}
				}
				 
				//si le plus petit x du tableau gauche est situe au y le plus petit
				if(xMinG==0){
					//on repere le plus petit x du tableau droite
					for (int k=1;k<(tabdroite.size());k++){
						if (tabdroite.get(xMaxD).x < tabdroite.get(k).x){
							xMaxD=k;
						}
					}
					//si le plus grand x du tableau droite est situe au y le plus petit
					if(xMaxD==0){
						estUnTriangle=true;
					}
					//si le plus grand x du tableau droite est situe au y le plus grand
					else if(xMaxD==tabdroite.size()-1){
						//on creer les variables qui nous servent a verifier si un point est dans la droite
						float y2=tabdroite.get(tabdroite.size()-1).y;
						float y1=(tabdroite.get(0)).y;
						float x2=tabdroite.get(tabdroite.size()-1).x;
						float x1=(tabdroite.get(0)).x;
						float X=tabdroite.get((tabdroite.size()-1)/3).x;
						float Y=tabdroite.get((tabdroite.size()-1)/3).y;
						float C=((y2-y1)/(x2-x1));
						float b=y1-(C*x1);
						float p=(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
						//on regarde pour plusieurs points si il y en a un qui appartient a l'equation de la droite
						for (int i=(tabgauche.size()-1)/4;i<tabgauche.size();i++){
							X=tabgauche.get(i).x;
							Y=tabgauche.get(i).y;
							p=(int)(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
							 if (p==0){
							    	estUnSegment=true;
							    }
							    else{
							    	estUnTriangle=true;
							    }
						}
						
					}
					else{
						estUnTriangle=true;
					}
				}
				//si le plus petit x du tableau gauche est situe au y le plus grand
				else if(xMinG==tabgauche.size()-1){
					//repere le plus grand x du tableau droite
					
					for (int k=1;k<(tabdroite.size());k++){
						if (tabdroite.get(xMaxD).x < tabdroite.get(k).x){
							xMaxD=k;
						}
					}
					//si le plus grand x du tableau droite est situe au y le plus petit
					if(xMaxD==0){
						//on creer les variables qui nous servent a verifier si un point est dans la droite
						float y2=tabdroite.get(tabdroite.size()-1).y;
						float y1=(tabdroite.get(0)).y;
						float x2=tabdroite.get(tabdroite.size()-1).x;
						float x1=(tabdroite.get(0)).x;
						float X=tabdroite.get((tabdroite.size()-1)/2).x;
						float Y=tabdroite.get((tabdroite.size()-1)/2).y;
						float C=((y2-y1)/(x2-x1));
						float b=y1-(C*x1);
						float p=(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
						//on regarde pour plusieurs points si il y en a un qui appartient a l'equation de la droite
						for (int i=(tabgauche.size()-1)/4;i<tabgauche.size();i++){
							X=tabgauche.get(i).x;
							Y=tabgauche.get(i).y;
							p=(int)(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
							 if (p==0){
							    	estUnSegment=true;
							    }
							    else{
							    	estUnTriangle=true;
							    }
						}
					}
					//si le plus grand x du tableau droite est situe au y le plus grand
					else if(xMaxD==tabgauche.size()-1){
						estUnTriangle=true;
					}
					else{
						estUnTriangle=true;
					}
				}
				//si le plus petit x du tableau gauche n'est ni situe au y le plus petit ni au y le plus grand c'est un triangle
				else{
					//on creer les variables qui nous servent a verifier si un point est dans la droite
					float y2=tabgauche.get(tabgauche.size()-1).y;
					float y1=(tabgauche.get(0)).y;
					float x2=tabgauche.get(tabgauche.size()-1).x;
					float x1=(tabgauche.get(0)).x;
					float X=tabgauche.get((tabgauche.size()-1)/2).x;
					float Y=tabgauche.get((tabgauche.size()-1)/2).y;
					float C=((y2-y1)/(x2-x1));
					float b=y1-(C*x1);
					float p=(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
					//on regarde pour plusieur point si il y en a un qui appartient a l'equation de la droite
					for (int i=(tabgauche.size()-1)/4;i<tabgauche.size();i++){
						X=tabgauche.get(i).x;
						Y=tabgauche.get(i).y;
						p=(int)(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
						 if (p==0){
						    	estUnSegment=true;
						    }
						    else{
						    	estUnTriangle=true;
						    }
					}
				   
				}
				if(estUnSegment){
					System.out.print("La forme est un segment de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
				}
				else {
					System.out.print("La forme est un triangle de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
					
				}
			}
		}

		



	}

}




----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1768)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3231)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1683)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1090)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1714)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1948)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-05-04 12:50:28.489
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1768)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3231)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1683)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1090)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1714)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1948)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-05-04 12:50:28.516
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1768)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3231)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1683)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1090)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1714)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1948)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-05-04 12:50:30.805
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package rechercheFormes;


import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;


public class RechercheFormes {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String uneLigne = null;
		//la ligne qu'on lit actuellement
		boolean fini = false;
		//pour arreter l'analyse
		int[] tablargeurhauteur = new int[2];
		//tableau qui recupere la largeur et la hauteur
		
		String schiffre ="";
		//variable servant a faire la concatenation des chiffres, qu'on transformera apres en entier 
	
		uneLigne = br.readLine();
		//recuperation de la largeur et la hauteur 
		
		
		int unchiffre = 0;
		// ici i =1 car on commence par le deuxieme caractere pour eviter le 1er caractere qui sera un '|'
		for (int i=1; i<= uneLigne.length()-1;i++){
			if(uneLigne.charAt(i)==' '){
			tablargeurhauteur[unchiffre]= Integer.parseInt(schiffre); 
				unchiffre++;
				schiffre = "";
			}
			else{
				
				schiffre = schiffre + uneLigne.charAt(i);
				
			}
			
			
		}
		
		int largeur = tablargeurhauteur[0]; //tablargeurhauteur[0] sera la largeur,
		int hauteur = tablargeurhauteur[1]; //tablargeurhauteur[1] sera la hauteur
		System.out.println("largeur de l'image = " + largeur);
		System.out.println("hauteur de l'image = " + hauteur);
		
		uneLigne = br.readLine();
		
		// recuperation de la valeur maximale pour chaque composante RGB (inutile)
		
		uneLigne = br.readLine();
		
		
		//ajout de toutes les valeurs dans une matrice 
		
		String [][] point = new String[hauteur][largeur];
		String uneCouleur ="";
		int ligne = 0;
		int colonne = 0;
		while (! fini){ 
			
			for (int i=1; i<= uneLigne.length()-1;i++){
				if(uneLigne.charAt(i)=='|'){
					point[colonne][ligne]= uneCouleur;
					colonne ++;
					uneCouleur ="";
					
				}
				else{
					uneCouleur = uneCouleur +uneLigne.charAt(i);
				}
				
	
			}
				ligne++;
				colonne = 0;
			
			
			uneLigne = br.readLine();


			if (uneLigne == null) {
			fini = true;
			}
			else{
			fini = false;
			}
		}
		br.close();	
		
		//recherche des points a gauche
		
		
		ArrayList<Points>tabgauche = new ArrayList<Points>();

		int jg = 0;
		boolean trouveg;
		
		for (int i=0; i< point.length;i++){
			trouveg = false;
			while (! trouveg){
				
				jg++;
				if(jg==point.length){
					trouveg = true;
				}
				else if (! point[jg][i].equals("255 255 255")){
					tabgauche.add(new Points(jg,i));
					trouveg = true;
					
				}
				else{
					trouveg = false;
				}
				
				
			}
			
			jg = 0;
		}
		
		
		//recherche des points a droite
		
		
		ArrayList<Points>tabdroite = new ArrayList<Points>();

		int jd = point[0].length;
		boolean trouved;
		
		for (int i=0; i< point.length;i++){
			trouved = false;
			while (! trouved){
				
				jd--;
				
				if(jd==0){
					trouved = true;
				}
				else if (! point[jd][i].equals("255 255 255")){
					
					tabdroite.add(new Points(jd,i));
					trouved = true;
					
				}
				else{
					trouved = false;
				}
				
				
			}
			
			jd = point[0].length;
			
		}


		
		//comparaison
		DictionnaireCouleur dico = new DictionnaireCouleur();

		
		
		boolean droiteverticalegauche = false;
		//regarde si la droite de gauche est vertical
		for (int i=0; i<tabgauche.size()-1;i++){
			if (tabgauche.get(i).x==tabgauche.get(i+1).x){
				droiteverticalegauche = true;
			}
			else{
				droiteverticalegauche = false;
				break;
			}
			

		}
		
		
		boolean droiteverticaledroite = false;
		//regarde si la droite de droite est vertical
		for (int i=0; i<tabdroite.size()-1;i++){
			if (tabdroite.get(i).x==tabdroite.get(i+1).x){
				droiteverticaledroite = true;
			}
			else{
				droiteverticaledroite = false;
				break;
			}
			

		}
		
		
		
		boolean memecol = false ;
		//regarde si la droite de gauche est la mÃªme que celle de droite
		for (int i=0; i<tabgauche.size();i++){
			if (tabgauche.get(i).x==tabdroite.get(i).x){
				memecol = true;
			}
			else{
				memecol = false;
			}
			
		}
		
		//regarde si les points constitus un point
		if(tabgauche.get(0).x==tabgauche.get(0).y && tabdroite.get(0).x==tabdroite.get(0).y && tabgauche.size()==1){
			System.out.println("La forme est le point(x="+tabgauche.get(0).x+",y="+tabgauche.get(0).y+") de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
		
		}
		
		else if(droiteverticalegauche && droiteverticaledroite){
			//regarde si les points constitus un segment vertical
			if(memecol){
				System.out.println("La forme est un segment vertical du point(x="+tabgauche.get(0).x+",y="+tabgauche.get(0).y+") au point(x="+tabgauche.get(tabgauche.size()-1).x+",y="+tabgauche.get(tabgauche.size()-1).y+") et de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
			}
			//regarde si les points constitus un rectangle
			else{
				
				System.out.println("La forme est un rectangle qui commence au point(x="+int(tabgauche.get(0).x+1+",y=")+int(tabgauche.get(0).y+1+") de largeur "+(tabdroite.get(0).x-tabgauche.get(0).x)+" pixels, de hauteur "+(tabgauche.get(tabgauche.size()-1).y-tabgauche.get(0).y)+" pixels et de couleur "+ dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
			}
		}
		else {
			boolean estUnCercle=true;
			//regarde si les points constitus un cercle
			for (int j=0;j<(tabgauche.size()/2);j++){
				if(tabgauche.get(j).x != tabgauche.get(tabgauche.size()-(j+1)).x && tabdroite.get(j).x != tabdroite.get(tabdroite.size()-(j+1)).x && !droiteverticalegauche &&  !droiteverticaledroite){
					estUnCercle=false;
				}
				
			}
			if(estUnCercle){
				System.out.print("La forme est un cercle de centre x="+(tabdroite.get((tabdroite.size()-1)/2).x-((tabdroite.get((tabdroite.size()-1)/2).x-tabgauche.get((tabgauche.size()-1)/2).x))/2));
				System.out.print(" y="+(tabgauche.get(tabgauche.size()-1).y-(tabgauche.get(tabgauche.size()-1).y-tabgauche.get(0).y)/2));
				System.out.print(" et de rayon "+(((tabdroite.get((tabdroite.size()-1)/2).x-tabgauche.get((tabgauche.size()-1)/2).x))/2)+" pixels");
				System.out.print(" de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
			}
			else{
				int xMinG=0;
				int xMaxD=0;
				boolean estUnTriangle=false;
				boolean estUnSegment=false;
				//repere le plus grand x du tableau gauche
				for (int k=1;k<(tabgauche.size());k++){
					if (tabgauche.get(xMinG).x > tabgauche.get(k).x){
						xMinG=k;
					}
				}
				 
				//si le plus petit x du tableau gauche est situe au y le plus petit
				if(xMinG==0){
					//on repere le plus petit x du tableau droite
					for (int k=1;k<(tabdroite.size());k++){
						if (tabdroite.get(xMaxD).x < tabdroite.get(k).x){
							xMaxD=k;
						}
					}
					//si le plus grand x du tableau droite est situe au y le plus petit
					if(xMaxD==0){
						estUnTriangle=true;
					}
					//si le plus grand x du tableau droite est situe au y le plus grand
					else if(xMaxD==tabdroite.size()-1){
						//on creer les variables qui nous servent a verifier si un point est dans la droite
						float y2=tabdroite.get(tabdroite.size()-1).y;
						float y1=(tabdroite.get(0)).y;
						float x2=tabdroite.get(tabdroite.size()-1).x;
						float x1=(tabdroite.get(0)).x;
						float X=tabdroite.get((tabdroite.size()-1)/3).x;
						float Y=tabdroite.get((tabdroite.size()-1)/3).y;
						float C=((y2-y1)/(x2-x1));
						float b=y1-(C*x1);
						float p=(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
						//on regarde pour plusieurs points si il y en a un qui appartient a l'equation de la droite
						for (int i=(tabgauche.size()-1)/4;i<tabgauche.size();i++){
							X=tabgauche.get(i).x;
							Y=tabgauche.get(i).y;
							p=(int)(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
							 if (p==0){
							    	estUnSegment=true;
							    }
							    else{
							    	estUnTriangle=true;
							    }
						}
						
					}
					else{
						estUnTriangle=true;
					}
				}
				//si le plus petit x du tableau gauche est situe au y le plus grand
				else if(xMinG==tabgauche.size()-1){
					//repere le plus grand x du tableau droite
					
					for (int k=1;k<(tabdroite.size());k++){
						if (tabdroite.get(xMaxD).x < tabdroite.get(k).x){
							xMaxD=k;
						}
					}
					//si le plus grand x du tableau droite est situe au y le plus petit
					if(xMaxD==0){
						//on creer les variables qui nous servent a verifier si un point est dans la droite
						float y2=tabdroite.get(tabdroite.size()-1).y;
						float y1=(tabdroite.get(0)).y;
						float x2=tabdroite.get(tabdroite.size()-1).x;
						float x1=(tabdroite.get(0)).x;
						float X=tabdroite.get((tabdroite.size()-1)/2).x;
						float Y=tabdroite.get((tabdroite.size()-1)/2).y;
						float C=((y2-y1)/(x2-x1));
						float b=y1-(C*x1);
						float p=(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
						//on regarde pour plusieurs points si il y en a un qui appartient a l'equation de la droite
						for (int i=(tabgauche.size()-1)/4;i<tabgauche.size();i++){
							X=tabgauche.get(i).x;
							Y=tabgauche.get(i).y;
							p=(int)(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
							 if (p==0){
							    	estUnSegment=true;
							    }
							    else{
							    	estUnTriangle=true;
							    }
						}
					}
					//si le plus grand x du tableau droite est situe au y le plus grand
					else if(xMaxD==tabgauche.size()-1){
						estUnTriangle=true;
					}
					else{
						estUnTriangle=true;
					}
				}
				//si le plus petit x du tableau gauche n'est ni situe au y le plus petit ni au y le plus grand c'est un triangle
				else{
					//on creer les variables qui nous servent a verifier si un point est dans la droite
					float y2=tabgauche.get(tabgauche.size()-1).y;
					float y1=(tabgauche.get(0)).y;
					float x2=tabgauche.get(tabgauche.size()-1).x;
					float x1=(tabgauche.get(0)).x;
					float X=tabgauche.get((tabgauche.size()-1)/2).x;
					float Y=tabgauche.get((tabgauche.size()-1)/2).y;
					float C=((y2-y1)/(x2-x1));
					float b=y1-(C*x1);
					float p=(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
					//on regarde pour plusieur point si il y en a un qui appartient a l'equation de la droite
					for (int i=(tabgauche.size()-1)/4;i<tabgauche.size();i++){
						X=tabgauche.get(i).x;
						Y=tabgauche.get(i).y;
						p=(int)(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
						 if (p==0){
						    	estUnSegment=true;
						    }
						    else{
						    	estUnTriangle=true;
						    }
					}
				   
				}
				if(estUnSegment){
					System.out.print("La forme est un segment de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
				}
				else {
					System.out.print("La forme est un triangle de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
					
				}
			}
		}

		



	}

}




----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1768)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3231)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1683)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1090)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1714)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1948)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-05-04 12:50:30.828
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1768)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3231)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1683)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1090)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1714)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1948)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-05-04 12:50:30.838
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1768)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3231)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1683)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1090)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1714)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1948)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-05-04 12:50:30.956
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package rechercheFormes;


import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;


public class RechercheFormes {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String uneLigne = null;
		//la ligne qu'on lit actuellement
		boolean fini = false;
		//pour arreter l'analyse
		int[] tablargeurhauteur = new int[2];
		//tableau qui recupere la largeur et la hauteur
		
		String schiffre ="";
		//variable servant a faire la concatenation des chiffres, qu'on transformera apres en entier 
	
		uneLigne = br.readLine();
		//recuperation de la largeur et la hauteur 
		
		
		int unchiffre = 0;
		// ici i =1 car on commence par le deuxieme caractere pour eviter le 1er caractere qui sera un '|'
		for (int i=1; i<= uneLigne.length()-1;i++){
			if(uneLigne.charAt(i)==' '){
			tablargeurhauteur[unchiffre]= Integer.parseInt(schiffre); 
				unchiffre++;
				schiffre = "";
			}
			else{
				
				schiffre = schiffre + uneLigne.charAt(i);
				
			}
			
			
		}
		
		int largeur = tablargeurhauteur[0]; //tablargeurhauteur[0] sera la largeur,
		int hauteur = tablargeurhauteur[1]; //tablargeurhauteur[1] sera la hauteur
		System.out.println("largeur de l'image = " + largeur);
		System.out.println("hauteur de l'image = " + hauteur);
		
		uneLigne = br.readLine();
		
		// recuperation de la valeur maximale pour chaque composante RGB (inutile)
		
		uneLigne = br.readLine();
		
		
		//ajout de toutes les valeurs dans une matrice 
		
		String [][] point = new String[hauteur][largeur];
		String uneCouleur ="";
		int ligne = 0;
		int colonne = 0;
		while (! fini){ 
			
			for (int i=1; i<= uneLigne.length()-1;i++){
				if(uneLigne.charAt(i)=='|'){
					point[colonne][ligne]= uneCouleur;
					colonne ++;
					uneCouleur ="";
					
				}
				else{
					uneCouleur = uneCouleur +uneLigne.charAt(i);
				}
				
	
			}
				ligne++;
				colonne = 0;
			
			
			uneLigne = br.readLine();


			if (uneLigne == null) {
			fini = true;
			}
			else{
			fini = false;
			}
		}
		br.close();	
		
		//recherche des points a gauche
		
		
		ArrayList<Points>tabgauche = new ArrayList<Points>();

		int jg = 0;
		boolean trouveg;
		
		for (int i=0; i< point.length;i++){
			trouveg = false;
			while (! trouveg){
				
				jg++;
				if(jg==point.length){
					trouveg = true;
				}
				else if (! point[jg][i].equals("255 255 255")){
					tabgauche.add(new Points(jg,i));
					trouveg = true;
					
				}
				else{
					trouveg = false;
				}
				
				
			}
			
			jg = 0;
		}
		
		
		//recherche des points a droite
		
		
		ArrayList<Points>tabdroite = new ArrayList<Points>();

		int jd = point[0].length;
		boolean trouved;
		
		for (int i=0; i< point.length;i++){
			trouved = false;
			while (! trouved){
				
				jd--;
				
				if(jd==0){
					trouved = true;
				}
				else if (! point[jd][i].equals("255 255 255")){
					
					tabdroite.add(new Points(jd,i));
					trouved = true;
					
				}
				else{
					trouved = false;
				}
				
				
			}
			
			jd = point[0].length;
			
		}


		
		//comparaison
		DictionnaireCouleur dico = new DictionnaireCouleur();

		
		
		boolean droiteverticalegauche = false;
		//regarde si la droite de gauche est vertical
		for (int i=0; i<tabgauche.size()-1;i++){
			if (tabgauche.get(i).x==tabgauche.get(i+1).x){
				droiteverticalegauche = true;
			}
			else{
				droiteverticalegauche = false;
				break;
			}
			

		}
		
		
		boolean droiteverticaledroite = false;
		//regarde si la droite de droite est vertical
		for (int i=0; i<tabdroite.size()-1;i++){
			if (tabdroite.get(i).x==tabdroite.get(i+1).x){
				droiteverticaledroite = true;
			}
			else{
				droiteverticaledroite = false;
				break;
			}
			

		}
		
		
		
		boolean memecol = false ;
		//regarde si la droite de gauche est la mÃªme que celle de droite
		for (int i=0; i<tabgauche.size();i++){
			if (tabgauche.get(i).x==tabdroite.get(i).x){
				memecol = true;
			}
			else{
				memecol = false;
			}
			
		}
		
		//regarde si les points constitus un point
		if(tabgauche.get(0).x==tabgauche.get(0).y && tabdroite.get(0).x==tabdroite.get(0).y && tabgauche.size()==1){
			System.out.println("La forme est le point(x="+tabgauche.get(0).x+",y="+tabgauche.get(0).y+") de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
		
		}
		
		else if(droiteverticalegauche && droiteverticaledroite){
			//regarde si les points constitus un segment vertical
			if(memecol){
				System.out.println("La forme est un segment vertical du point(x="+tabgauche.get(0).x+",y="+tabgauche.get(0).y+") au point(x="+tabgauche.get(tabgauche.size()-1).x+",y="+tabgauche.get(tabgauche.size()-1).y+") et de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
			}
			//regarde si les points constitus un rectangle
			else{
				
				System.out.println("La forme est un rectangle qui commence au point(x="+int(tabgauche.get(0).x+1+",y=")+int(tabgauche.get(0).y+1+") de largeur "+(tabdroite.get(0).x-tabgauche.get(0).x)+" pixels, de hauteur "+(tabgauche.get(tabgauche.size()-1).y-tabgauche.get(0).y)+" pixels et de couleur "+ dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
			}
		}
		else {
			boolean estUnCercle=true;
			//regarde si les points constitus un cercle
			for (int j=0;j<(tabgauche.size()/2);j++){
				if(tabgauche.get(j).x != tabgauche.get(tabgauche.size()-(j+1)).x && tabdroite.get(j).x != tabdroite.get(tabdroite.size()-(j+1)).x && !droiteverticalegauche &&  !droiteverticaledroite){
					estUnCercle=false;
				}
				
			}
			if(estUnCercle){
				System.out.print("La forme est un cercle de centre x="+(tabdroite.get((tabdroite.size()-1)/2).x-((tabdroite.get((tabdroite.size()-1)/2).x-tabgauche.get((tabgauche.size()-1)/2).x))/2));
				System.out.print(" y="+(tabgauche.get(tabgauche.size()-1).y-(tabgauche.get(tabgauche.size()-1).y-tabgauche.get(0).y)/2));
				System.out.print(" et de rayon "+(((tabdroite.get((tabdroite.size()-1)/2).x-tabgauche.get((tabgauche.size()-1)/2).x))/2)+" pixels");
				System.out.print(" de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
			}
			else{
				int xMinG=0;
				int xMaxD=0;
				boolean estUnTriangle=false;
				boolean estUnSegment=false;
				//repere le plus grand x du tableau gauche
				for (int k=1;k<(tabgauche.size());k++){
					if (tabgauche.get(xMinG).x > tabgauche.get(k).x){
						xMinG=k;
					}
				}
				 
				//si le plus petit x du tableau gauche est situe au y le plus petit
				if(xMinG==0){
					//on repere le plus petit x du tableau droite
					for (int k=1;k<(tabdroite.size());k++){
						if (tabdroite.get(xMaxD).x < tabdroite.get(k).x){
							xMaxD=k;
						}
					}
					//si le plus grand x du tableau droite est situe au y le plus petit
					if(xMaxD==0){
						estUnTriangle=true;
					}
					//si le plus grand x du tableau droite est situe au y le plus grand
					else if(xMaxD==tabdroite.size()-1){
						//on creer les variables qui nous servent a verifier si un point est dans la droite
						float y2=tabdroite.get(tabdroite.size()-1).y;
						float y1=(tabdroite.get(0)).y;
						float x2=tabdroite.get(tabdroite.size()-1).x;
						float x1=(tabdroite.get(0)).x;
						float X=tabdroite.get((tabdroite.size()-1)/3).x;
						float Y=tabdroite.get((tabdroite.size()-1)/3).y;
						float C=((y2-y1)/(x2-x1));
						float b=y1-(C*x1);
						float p=(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
						//on regarde pour plusieurs points si il y en a un qui appartient a l'equation de la droite
						for (int i=(tabgauche.size()-1)/4;i<tabgauche.size();i++){
							X=tabgauche.get(i).x;
							Y=tabgauche.get(i).y;
							p=(int)(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
							 if (p==0){
							    	estUnSegment=true;
							    }
							    else{
							    	estUnTriangle=true;
							    }
						}
						
					}
					else{
						estUnTriangle=true;
					}
				}
				//si le plus petit x du tableau gauche est situe au y le plus grand
				else if(xMinG==tabgauche.size()-1){
					//repere le plus grand x du tableau droite
					
					for (int k=1;k<(tabdroite.size());k++){
						if (tabdroite.get(xMaxD).x < tabdroite.get(k).x){
							xMaxD=k;
						}
					}
					//si le plus grand x du tableau droite est situe au y le plus petit
					if(xMaxD==0){
						//on creer les variables qui nous servent a verifier si un point est dans la droite
						float y2=tabdroite.get(tabdroite.size()-1).y;
						float y1=(tabdroite.get(0)).y;
						float x2=tabdroite.get(tabdroite.size()-1).x;
						float x1=(tabdroite.get(0)).x;
						float X=tabdroite.get((tabdroite.size()-1)/2).x;
						float Y=tabdroite.get((tabdroite.size()-1)/2).y;
						float C=((y2-y1)/(x2-x1));
						float b=y1-(C*x1);
						float p=(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
						//on regarde pour plusieurs points si il y en a un qui appartient a l'equation de la droite
						for (int i=(tabgauche.size()-1)/4;i<tabgauche.size();i++){
							X=tabgauche.get(i).x;
							Y=tabgauche.get(i).y;
							p=(int)(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
							 if (p==0){
							    	estUnSegment=true;
							    }
							    else{
							    	estUnTriangle=true;
							    }
						}
					}
					//si le plus grand x du tableau droite est situe au y le plus grand
					else if(xMaxD==tabgauche.size()-1){
						estUnTriangle=true;
					}
					else{
						estUnTriangle=true;
					}
				}
				//si le plus petit x du tableau gauche n'est ni situe au y le plus petit ni au y le plus grand c'est un triangle
				else{
					//on creer les variables qui nous servent a verifier si un point est dans la droite
					float y2=tabgauche.get(tabgauche.size()-1).y;
					float y1=(tabgauche.get(0)).y;
					float x2=tabgauche.get(tabgauche.size()-1).x;
					float x1=(tabgauche.get(0)).x;
					float X=tabgauche.get((tabgauche.size()-1)/2).x;
					float Y=tabgauche.get((tabgauche.size()-1)/2).y;
					float C=((y2-y1)/(x2-x1));
					float b=y1-(C*x1);
					float p=(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
					//on regarde pour plusieur point si il y en a un qui appartient a l'equation de la droite
					for (int i=(tabgauche.size()-1)/4;i<tabgauche.size();i++){
						X=tabgauche.get(i).x;
						Y=tabgauche.get(i).y;
						p=(int)(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
						 if (p==0){
						    	estUnSegment=true;
						    }
						    else{
						    	estUnTriangle=true;
						    }
					}
				   
				}
				if(estUnSegment){
					System.out.print("La forme est un segment de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
				}
				else {
					System.out.print("La forme est un triangle de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
					
				}
			}
		}

		



	}

}




----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1768)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3231)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1683)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1090)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1714)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1948)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 2 2015-05-04 12:50:30.976
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1768)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3231)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1683)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1090)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1714)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1948)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 0 2015-05-04 12:50:30.987
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1768)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3231)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1683)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1090)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1714)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1948)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.core 4 4 2015-05-04 12:52:37.756
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package rechercheFormes;


import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;


public class RechercheFormes {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String uneLigne = null;
		//la ligne qu'on lit actuellement
		boolean fini = false;
		//pour arreter l'analyse
		int[] tablargeurhauteur = new int[2];
		//tableau qui recupere la largeur et la hauteur
		
		String schiffre ="";
		//variable servant a faire la concatenation des chiffres, qu'on transformera apres en entier 
	
		uneLigne = br.readLine();
		//recuperation de la largeur et la hauteur 
		
		
		int unchiffre = 0;
		// ici i =1 car on commence par le deuxieme caractere pour eviter le 1er caractere qui sera un '|'
		for (int i=1; i<= uneLigne.length()-1;i++){
			if(uneLigne.charAt(i)==' '){
			tablargeurhauteur[unchiffre]= Integer.parseInt(schiffre); 
				unchiffre++;
				schiffre = "";
			}
			else{
				
				schiffre = schiffre + uneLigne.charAt(i);
				
			}
			
			
		}
		
		int largeur = tablargeurhauteur[0]; //tablargeurhauteur[0] sera la largeur,
		int hauteur = tablargeurhauteur[1]; //tablargeurhauteur[1] sera la hauteur
		System.out.println("largeur de l'image = " + largeur);
		System.out.println("hauteur de l'image = " + hauteur);
		
		uneLigne = br.readLine();
		
		// recuperation de la valeur maximale pour chaque composante RGB (inutile)
		
		uneLigne = br.readLine();
		
		
		//ajout de toutes les valeurs dans une matrice 
		
		String [][] point = new String[hauteur][largeur];
		String uneCouleur ="";
		int ligne = 0;
		int colonne = 0;
		while (! fini){ 
			
			for (int i=1; i<= uneLigne.length()-1;i++){
				if(uneLigne.charAt(i)=='|'){
					point[colonne][ligne]= uneCouleur;
					colonne ++;
					uneCouleur ="";
					
				}
				else{
					uneCouleur = uneCouleur +uneLigne.charAt(i);
				}
				
	
			}
				ligne++;
				colonne = 0;
			
			
			uneLigne = br.readLine();


			if (uneLigne == null) {
			fini = true;
			}
			else{
			fini = false;
			}
		}
		br.close();	
		
		//recherche des points a gauche
		
		
		ArrayList<Points>tabgauche = new ArrayList<Points>();

		int jg = 0;
		boolean trouveg;
		
		for (int i=0; i< point.length;i++){
			trouveg = false;
			while (! trouveg){
				
				jg++;
				if(jg==point.length){
					trouveg = true;
				}
				else if (! point[jg][i].equals("255 255 255")){
					tabgauche.add(new Points(jg,i));
					trouveg = true;
					
				}
				else{
					trouveg = false;
				}
				
				
			}
			
			jg = 0;
		}
		
		
		//recherche des points a droite
		
		
		ArrayList<Points>tabdroite = new ArrayList<Points>();

		int jd = point[0].length;
		boolean trouved;
		
		for (int i=0; i< point.length;i++){
			trouved = false;
			while (! trouved){
				
				jd--;
				
				if(jd==0){
					trouved = true;
				}
				else if (! point[jd][i].equals("255 255 255")){
					
					tabdroite.add(new Points(jd,i));
					trouved = true;
					
				}
				else{
					trouved = false;
				}
				
				
			}
			
			jd = point[0].length;
			
		}


		
		//comparaison
		DictionnaireCouleur dico = new DictionnaireCouleur();

		
		
		boolean droiteverticalegauche = false;
		//regarde si la droite de gauche est vertical
		for (int i=0; i<tabgauche.size()-1;i++){
			if (tabgauche.get(i).x==tabgauche.get(i+1).x){
				droiteverticalegauche = true;
			}
			else{
				droiteverticalegauche = false;
				break;
			}
			

		}
		
		
		boolean droiteverticaledroite = false;
		//regarde si la droite de droite est vertical
		for (int i=0; i<tabdroite.size()-1;i++){
			if (tabdroite.get(i).x==tabdroite.get(i+1).x){
				droiteverticaledroite = true;
			}
			else{
				droiteverticaledroite = false;
				break;
			}
			

		}
		
		
		
		boolean memecol = false ;
		//regarde si la droite de gauche est la mÃªme que celle de droite
		for (int i=0; i<tabgauche.size();i++){
			if (tabgauche.get(i).x==tabdroite.get(i).x){
				memecol = true;
			}
			else{
				memecol = false;
			}
			
		}
		
		//regarde si les points constitus un point
		if(tabgauche.get(0).x==tabgauche.get(0).y && tabdroite.get(0).x==tabdroite.get(0).y && tabgauche.size()==1){
			System.out.println("La forme est le point(x="+tabgauche.get(0).x+",y="+tabgauche.get(0).y+") de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
		
		}
		
		else if(droiteverticalegauche && droiteverticaledroite){
			//regarde si les points constitus un segment vertical
			if(memecol){
				System.out.println("La forme est un segment vertical du point(x="+tabgauche.get(0).x+",y="+tabgauche.get(0).y+") au point(x="+tabgauche.get(tabgauche.size()-1).x+",y="+tabgauche.get(tabgauche.size()-1).y+") et de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
			}
			//regarde si les points constitus un rectangle
			else{
				
				System.out.println("La forme est un rectangle qui commence au point(x="+int(tabgauche.get(0).x+1+",y=")+int(tabgauche.get(0).y+1+") de largeur "+(tabdroite.get(0).x-tabgauche.get(0).x)+" pixels, de hauteur "+(tabgauche.get(tabgauche.size()-1).y-tabgauche.get(0).y)+" pixels et de couleur "+ dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
			}
		}
		else {
			boolean estUnCercle=true;
			//regarde si les points constitus un cercle
			for (int j=0;j<(tabgauche.size()/2);j++){
				if(tabgauche.get(j).x != tabgauche.get(tabgauche.size()-(j+1)).x && tabdroite.get(j).x != tabdroite.get(tabdroite.size()-(j+1)).x && !droiteverticalegauche &&  !droiteverticaledroite){
					estUnCercle=false;
				}
				
			}
			if(estUnCercle){
				System.out.print("La forme est un cercle de centre x="+(tabdroite.get((tabdroite.size()-1)/2).x-((tabdroite.get((tabdroite.size()-1)/2).x-tabgauche.get((tabgauche.size()-1)/2).x))/2));
				System.out.print(" y="+(tabgauche.get(tabgauche.size()-1).y-(tabgauche.get(tabgauche.size()-1).y-tabgauche.get(0).y)/2));
				System.out.print(" et de rayon "+(((tabdroite.get((tabdroite.size()-1)/2).x-tabgauche.get((tabgauche.size()-1)/2).x))/2)+" pixels");
				System.out.print(" de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
			}
			else{
				int xMinG=0;
				int xMaxD=0;
				boolean estUnTriangle=false;
				boolean estUnSegment=false;
				//repere le plus grand x du tableau gauche
				for (int k=1;k<(tabgauche.size());k++){
					if (tabgauche.get(xMinG).x > tabgauche.get(k).x){
						xMinG=k;
					}
				}
				 
				//si le plus petit x du tableau gauche est situe au y le plus petit
				if(xMinG==0){
					//on repere le plus petit x du tableau droite
					for (int k=1;k<(tabdroite.size());k++){
						if (tabdroite.get(xMaxD).x < tabdroite.get(k).x){
							xMaxD=k;
						}
					}
					//si le plus grand x du tableau droite est situe au y le plus petit
					if(xMaxD==0){
						estUnTriangle=true;
					}
					//si le plus grand x du tableau droite est situe au y le plus grand
					else if(xMaxD==tabdroite.size()-1){
						//on creer les variables qui nous servent a verifier si un point est dans la droite
						float y2=tabdroite.get(tabdroite.size()-1).y;
						float y1=(tabdroite.get(0)).y;
						float x2=tabdroite.get(tabdroite.size()-1).x;
						float x1=(tabdroite.get(0)).x;
						float X=tabdroite.get((tabdroite.size()-1)/3).x;
						float Y=tabdroite.get((tabdroite.size()-1)/3).y;
						float C=((y2-y1)/(x2-x1));
						float b=y1-(C*x1);
						float p=(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
						//on regarde pour plusieurs points si il y en a un qui appartient a l'equation de la droite
						for (int i=(tabgauche.size()-1)/4;i<tabgauche.size();i++){
							X=tabgauche.get(i).x;
							Y=tabgauche.get(i).y;
							p=(int)(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
							 if (p==0){
							    	estUnSegment=true;
							    }
							    else{
							    	estUnTriangle=true;
							    }
						}
						
					}
					else{
						estUnTriangle=true;
					}
				}
				//si le plus petit x du tableau gauche est situe au y le plus grand
				else if(xMinG==tabgauche.size()-1){
					//repere le plus grand x du tableau droite
					
					for (int k=1;k<(tabdroite.size());k++){
						if (tabdroite.get(xMaxD).x < tabdroite.get(k).x){
							xMaxD=k;
						}
					}
					//si le plus grand x du tableau droite est situe au y le plus petit
					if(xMaxD==0){
						//on creer les variables qui nous servent a verifier si un point est dans la droite
						float y2=tabdroite.get(tabdroite.size()-1).y;
						float y1=(tabdroite.get(0)).y;
						float x2=tabdroite.get(tabdroite.size()-1).x;
						float x1=(tabdroite.get(0)).x;
						float X=tabdroite.get((tabdroite.size()-1)/2).x;
						float Y=tabdroite.get((tabdroite.size()-1)/2).y;
						float C=((y2-y1)/(x2-x1));
						float b=y1-(C*x1);
						float p=(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
						//on regarde pour plusieurs points si il y en a un qui appartient a l'equation de la droite
						for (int i=(tabgauche.size()-1)/4;i<tabgauche.size();i++){
							X=tabgauche.get(i).x;
							Y=tabgauche.get(i).y;
							p=(int)(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
							 if (p==0){
							    	estUnSegment=true;
							    }
							    else{
							    	estUnTriangle=true;
							    }
						}
					}
					//si le plus grand x du tableau droite est situe au y le plus grand
					else if(xMaxD==tabgauche.size()-1){
						estUnTriangle=true;
					}
					else{
						estUnTriangle=true;
					}
				}
				//si le plus petit x du tableau gauche n'est ni situe au y le plus petit ni au y le plus grand c'est un triangle
				else{
					//on creer les variables qui nous servent a verifier si un point est dans la droite
					float y2=tabgauche.get(tabgauche.size()-1).y;
					float y1=(tabgauche.get(0)).y;
					float x2=tabgauche.get(tabgauche.size()-1).x;
					float x1=(tabgauche.get(0)).x;
					float X=tabgauche.get((tabgauche.size()-1)/2).x;
					float Y=tabgauche.get((tabgauche.size()-1)/2).y;
					float C=((y2-y1)/(x2-x1));
					float b=y1-(C*x1);
					float p=(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
					//on regarde pour plusieur point si il y en a un qui appartient a l'equation de la droite
					for (int i=(tabgauche.size()-1)/4;i<tabgauche.size();i++){
						X=tabgauche.get(i).x;
						Y=tabgauche.get(i).y;
						p=(int)(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
						 if (p==0){
						    	estUnSegment=true;
						    }
						    else{
						    	estUnTriangle=true;
						    }
					}
				   
				}
				if(estUnSegment){
					System.out.print("La forme est un segment de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
				}
				else {
					System.out.print("La forme est un triangle de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
					
				}
			}
		}

		



	}

}




----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1768)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3231)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1683)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1090)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1714)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1948)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-05-04 12:52:37.778
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1768)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3231)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1683)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1090)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1714)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1948)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-05-04 12:52:37.797
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1768)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3231)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1683)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1090)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1714)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1948)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-05-04 12:52:37.875
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package rechercheFormes;


import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;


public class RechercheFormes {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String uneLigne = null;
		//la ligne qu'on lit actuellement
		boolean fini = false;
		//pour arreter l'analyse
		int[] tablargeurhauteur = new int[2];
		//tableau qui recupere la largeur et la hauteur
		
		String schiffre ="";
		//variable servant a faire la concatenation des chiffres, qu'on transformera apres en entier 
	
		uneLigne = br.readLine();
		//recuperation de la largeur et la hauteur 
		
		
		int unchiffre = 0;
		// ici i =1 car on commence par le deuxieme caractere pour eviter le 1er caractere qui sera un '|'
		for (int i=1; i<= uneLigne.length()-1;i++){
			if(uneLigne.charAt(i)==' '){
			tablargeurhauteur[unchiffre]= Integer.parseInt(schiffre); 
				unchiffre++;
				schiffre = "";
			}
			else{
				
				schiffre = schiffre + uneLigne.charAt(i);
				
			}
			
			
		}
		
		int largeur = tablargeurhauteur[0]; //tablargeurhauteur[0] sera la largeur,
		int hauteur = tablargeurhauteur[1]; //tablargeurhauteur[1] sera la hauteur
		System.out.println("largeur de l'image = " + largeur);
		System.out.println("hauteur de l'image = " + hauteur);
		
		uneLigne = br.readLine();
		
		// recuperation de la valeur maximale pour chaque composante RGB (inutile)
		
		uneLigne = br.readLine();
		
		
		//ajout de toutes les valeurs dans une matrice 
		
		String [][] point = new String[hauteur][largeur];
		String uneCouleur ="";
		int ligne = 0;
		int colonne = 0;
		while (! fini){ 
			
			for (int i=1; i<= uneLigne.length()-1;i++){
				if(uneLigne.charAt(i)=='|'){
					point[colonne][ligne]= uneCouleur;
					colonne ++;
					uneCouleur ="";
					
				}
				else{
					uneCouleur = uneCouleur +uneLigne.charAt(i);
				}
				
	
			}
				ligne++;
				colonne = 0;
			
			
			uneLigne = br.readLine();


			if (uneLigne == null) {
			fini = true;
			}
			else{
			fini = false;
			}
		}
		br.close();	
		
		//recherche des points a gauche
		
		
		ArrayList<Points>tabgauche = new ArrayList<Points>();

		int jg = 0;
		boolean trouveg;
		
		for (int i=0; i< point.length;i++){
			trouveg = false;
			while (! trouveg){
				
				jg++;
				if(jg==point.length){
					trouveg = true;
				}
				else if (! point[jg][i].equals("255 255 255")){
					tabgauche.add(new Points(jg,i));
					trouveg = true;
					
				}
				else{
					trouveg = false;
				}
				
				
			}
			
			jg = 0;
		}
		
		
		//recherche des points a droite
		
		
		ArrayList<Points>tabdroite = new ArrayList<Points>();

		int jd = point[0].length;
		boolean trouved;
		
		for (int i=0; i< point.length;i++){
			trouved = false;
			while (! trouved){
				
				jd--;
				
				if(jd==0){
					trouved = true;
				}
				else if (! point[jd][i].equals("255 255 255")){
					
					tabdroite.add(new Points(jd,i));
					trouved = true;
					
				}
				else{
					trouved = false;
				}
				
				
			}
			
			jd = point[0].length;
			
		}


		
		//comparaison
		DictionnaireCouleur dico = new DictionnaireCouleur();

		
		
		boolean droiteverticalegauche = false;
		//regarde si la droite de gauche est vertical
		for (int i=0; i<tabgauche.size()-1;i++){
			if (tabgauche.get(i).x==tabgauche.get(i+1).x){
				droiteverticalegauche = true;
			}
			else{
				droiteverticalegauche = false;
				break;
			}
			

		}
		
		
		boolean droiteverticaledroite = false;
		//regarde si la droite de droite est vertical
		for (int i=0; i<tabdroite.size()-1;i++){
			if (tabdroite.get(i).x==tabdroite.get(i+1).x){
				droiteverticaledroite = true;
			}
			else{
				droiteverticaledroite = false;
				break;
			}
			

		}
		
		
		
		boolean memecol = false ;
		//regarde si la droite de gauche est la mÃªme que celle de droite
		for (int i=0; i<tabgauche.size();i++){
			if (tabgauche.get(i).x==tabdroite.get(i).x){
				memecol = true;
			}
			else{
				memecol = false;
			}
			
		}
		
		//regarde si les points constitus un point
		if(tabgauche.get(0).x==tabgauche.get(0).y && tabdroite.get(0).x==tabdroite.get(0).y && tabgauche.size()==1){
			System.out.println("La forme est le point(x="+tabgauche.get(0).x+",y="+tabgauche.get(0).y+") de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
		
		}
		
		else if(droiteverticalegauche && droiteverticaledroite){
			//regarde si les points constitus un segment vertical
			if(memecol){
				System.out.println("La forme est un segment vertical du point(x="+tabgauche.get(0).x+",y="+tabgauche.get(0).y+") au point(x="+tabgauche.get(tabgauche.size()-1).x+",y="+tabgauche.get(tabgauche.size()-1).y+") et de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
			}
			//regarde si les points constitus un rectangle
			else{
				
				System.out.println("La forme est un rectangle qui commence au point(x="+int(tabgauche.get(0).x+1+",y=")+int(tabgauche.get(0).y+1+") de largeur "+(tabdroite.get(0).x-tabgauche.get(0).x)+" pixels, de hauteur "+(tabgauche.get(tabgauche.size()-1).y-tabgauche.get(0).y)+" pixels et de couleur "+ dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
			}
		}
		else {
			boolean estUnCercle=true;
			//regarde si les points constitus un cercle
			for (int j=0;j<(tabgauche.size()/2);j++){
				if(tabgauche.get(j).x != tabgauche.get(tabgauche.size()-(j+1)).x && tabdroite.get(j).x != tabdroite.get(tabdroite.size()-(j+1)).x && !droiteverticalegauche &&  !droiteverticaledroite){
					estUnCercle=false;
				}
				
			}
			if(estUnCercle){
				System.out.print("La forme est un cercle de centre x="+(tabdroite.get((tabdroite.size()-1)/2).x-((tabdroite.get((tabdroite.size()-1)/2).x-tabgauche.get((tabgauche.size()-1)/2).x))/2));
				System.out.print(" y="+(tabgauche.get(tabgauche.size()-1).y-(tabgauche.get(tabgauche.size()-1).y-tabgauche.get(0).y)/2));
				System.out.print(" et de rayon "+(((tabdroite.get((tabdroite.size()-1)/2).x-tabgauche.get((tabgauche.size()-1)/2).x))/2)+" pixels");
				System.out.print(" de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
			}
			else{
				int xMinG=0;
				int xMaxD=0;
				boolean estUnTriangle=false;
				boolean estUnSegment=false;
				//repere le plus grand x du tableau gauche
				for (int k=1;k<(tabgauche.size());k++){
					if (tabgauche.get(xMinG).x > tabgauche.get(k).x){
						xMinG=k;
					}
				}
				 
				//si le plus petit x du tableau gauche est situe au y le plus petit
				if(xMinG==0){
					//on repere le plus petit x du tableau droite
					for (int k=1;k<(tabdroite.size());k++){
						if (tabdroite.get(xMaxD).x < tabdroite.get(k).x){
							xMaxD=k;
						}
					}
					//si le plus grand x du tableau droite est situe au y le plus petit
					if(xMaxD==0){
						estUnTriangle=true;
					}
					//si le plus grand x du tableau droite est situe au y le plus grand
					else if(xMaxD==tabdroite.size()-1){
						//on creer les variables qui nous servent a verifier si un point est dans la droite
						float y2=tabdroite.get(tabdroite.size()-1).y;
						float y1=(tabdroite.get(0)).y;
						float x2=tabdroite.get(tabdroite.size()-1).x;
						float x1=(tabdroite.get(0)).x;
						float X=tabdroite.get((tabdroite.size()-1)/3).x;
						float Y=tabdroite.get((tabdroite.size()-1)/3).y;
						float C=((y2-y1)/(x2-x1));
						float b=y1-(C*x1);
						float p=(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
						//on regarde pour plusieurs points si il y en a un qui appartient a l'equation de la droite
						for (int i=(tabgauche.size()-1)/4;i<tabgauche.size();i++){
							X=tabgauche.get(i).x;
							Y=tabgauche.get(i).y;
							p=(int)(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
							 if (p==0){
							    	estUnSegment=true;
							    }
							    else{
							    	estUnTriangle=true;
							    }
						}
						
					}
					else{
						estUnTriangle=true;
					}
				}
				//si le plus petit x du tableau gauche est situe au y le plus grand
				else if(xMinG==tabgauche.size()-1){
					//repere le plus grand x du tableau droite
					
					for (int k=1;k<(tabdroite.size());k++){
						if (tabdroite.get(xMaxD).x < tabdroite.get(k).x){
							xMaxD=k;
						}
					}
					//si le plus grand x du tableau droite est situe au y le plus petit
					if(xMaxD==0){
						//on creer les variables qui nous servent a verifier si un point est dans la droite
						float y2=tabdroite.get(tabdroite.size()-1).y;
						float y1=(tabdroite.get(0)).y;
						float x2=tabdroite.get(tabdroite.size()-1).x;
						float x1=(tabdroite.get(0)).x;
						float X=tabdroite.get((tabdroite.size()-1)/2).x;
						float Y=tabdroite.get((tabdroite.size()-1)/2).y;
						float C=((y2-y1)/(x2-x1));
						float b=y1-(C*x1);
						float p=(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
						//on regarde pour plusieurs points si il y en a un qui appartient a l'equation de la droite
						for (int i=(tabgauche.size()-1)/4;i<tabgauche.size();i++){
							X=tabgauche.get(i).x;
							Y=tabgauche.get(i).y;
							p=(int)(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
							 if (p==0){
							    	estUnSegment=true;
							    }
							    else{
							    	estUnTriangle=true;
							    }
						}
					}
					//si le plus grand x du tableau droite est situe au y le plus grand
					else if(xMaxD==tabgauche.size()-1){
						estUnTriangle=true;
					}
					else{
						estUnTriangle=true;
					}
				}
				//si le plus petit x du tableau gauche n'est ni situe au y le plus petit ni au y le plus grand c'est un triangle
				else{
					//on creer les variables qui nous servent a verifier si un point est dans la droite
					float y2=tabgauche.get(tabgauche.size()-1).y;
					float y1=(tabgauche.get(0)).y;
					float x2=tabgauche.get(tabgauche.size()-1).x;
					float x1=(tabgauche.get(0)).x;
					float X=tabgauche.get((tabgauche.size()-1)/2).x;
					float Y=tabgauche.get((tabgauche.size()-1)/2).y;
					float C=((y2-y1)/(x2-x1));
					float b=y1-(C*x1);
					float p=(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
					//on regarde pour plusieur point si il y en a un qui appartient a l'equation de la droite
					for (int i=(tabgauche.size()-1)/4;i<tabgauche.size();i++){
						X=tabgauche.get(i).x;
						Y=tabgauche.get(i).y;
						p=(int)(y2-y1)*X-Y*(x2-x1)+b*(x2-x1);
						 if (p==0){
						    	estUnSegment=true;
						    }
						    else{
						    	estUnTriangle=true;
						    }
					}
				   
				}
				if(estUnSegment){
					System.out.print("La forme est un segment de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
				}
				else {
					System.out.print("La forme est un triangle de couleur "+dico.donneCouleur(point[tabgauche.get(0).x][tabgauche.get(0).y]));
					
				}
			}
		}

		



	}

}




----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1768)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3231)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1683)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1090)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1714)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1948)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-05-04 12:52:37.929
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1768)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3231)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1683)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1090)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1714)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1948)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-05-04 12:52:37.948
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1222)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1768)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3231)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1683)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1090)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1714)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2681)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1948)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2705)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
